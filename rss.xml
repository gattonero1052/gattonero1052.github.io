<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[MSKf's Tree BLOG]]></title><description><![CDATA[Personal blog of mskf]]></description><link>https://mskf.work/</link><image><url>https://mskf.work//logos/logo-512.png</url><title>MSKf&apos;s Tree BLOG</title><link>https://mskf.work/</link></image><generator>GatsbyJS Advanced Starter</generator><lastBuildDate>Tue, 22 Jun 2021 08:25:27 GMT</lastBuildDate><atom:link href="https://mskf.work//rss.xml" rel="self" type="application/rss+xml"/><copyright><![CDATA[Copyright © 2019. Advanced User]]></copyright><item><title><![CDATA[How did I build a responsive Landing page using tailwindcss]]></title><description><![CDATA[Environment, IDE, Tech stacks, Public resources NodeJS 12.20.0 VSCode React, tailwindcss dev.to Steps One day when I was busy living, I got…]]></description><link>https://mskf.work//FrontEnd/how-did-i-build-a-responsive-landing-page-using-tailwindcss</link><guid isPermaLink="false">https://mskf.work//FrontEnd/how-did-i-build-a-responsive-landing-page-using-tailwindcss</guid><category><![CDATA[2010]]></category><category><![CDATA[Frontend]]></category><content:encoded/><author>gattonero1052@example.com</author></item><item><title><![CDATA[Calculator]]></title><description><![CDATA[https://leetcode.com/problems/basic-calculator-iii/ Problem Implement a basic calculator supporting +  - * / Parentheses () And do not need…]]></description><link>https://mskf.work//algorithm/calculator</link><guid isPermaLink="false">https://mskf.work//algorithm/calculator</guid><category><![CDATA[calculator]]></category><category><![CDATA[algorithm]]></category><category><![CDATA[leetcode]]></category><category><![CDATA[python]]></category><pubDate>Tue, 22 Jun 2021 04:00:00 GMT</pubDate><content:encoded/><author>gattonero1052@example.com</author></item><item><title><![CDATA[Bash Scripting Examples]]></title><description><![CDATA[Bash scripting This is a problem oriented bash scripting post. For understanding what's going on and how the code works, it's of great help…]]></description><link>https://mskf.work//Bash/bash-scripting-examples</link><guid isPermaLink="false">https://mskf.work//Bash/bash-scripting-examples</guid><category><![CDATA[bash]]></category><pubDate>Tue, 17 Mar 2020 04:00:00 GMT</pubDate><content:encoded/><author>gattonero1052@example.com</author></item><item><title><![CDATA[Poker Game]]></title><description><![CDATA[一个Web扑克游戏 —— 用不着机器学习也能解决这个问题 A poker game based on browser, only using basic algorithms 游戏地址 游戏地址 概要 这里我主要用中文来讲述poker game…]]></description><link>https://mskf.work//Game/poker-game</link><guid isPermaLink="false">https://mskf.work//Game/poker-game</guid><category><![CDATA[中文]]></category><category><![CDATA[Game]]></category><category><![CDATA[Javascript]]></category><category><![CDATA[React]]></category><category><![CDATA[PWA]]></category><category><![CDATA[WebGame]]></category><pubDate>Sun, 22 Dec 2019 05:00:00 GMT</pubDate><content:encoded/><author>gattonero1052@example.com</author></item><item><title><![CDATA[Java Generics Tricky Code]]></title><description><![CDATA[Purpose 收集整理一些比较难以理解的Java泛型问题，以及详细解释其中的原理 List Wildcards PECS (Producer extend, Consumer super) Class and Interface Producer 其中 ? extends…]]></description><link>https://mskf.work//Java/java-generics-tricky-code</link><guid isPermaLink="false">https://mskf.work//Java/java-generics-tricky-code</guid><category><![CDATA[中文]]></category><category><![CDATA[java]]></category><category><![CDATA[generics]]></category><pubDate>Fri, 25 Oct 2019 04:00:00 GMT</pubDate><content:encoded/><author>gattonero1052@example.com</author></item><item><title><![CDATA[Big Number Multiply]]></title><description><![CDATA[问题 适用于1000位以内数的乘法 思路 注意两点： 数字是通过字符串传过来的，字符串的低位反而是数字的高位，所以我们要从数字的低位开始计算的话，必须反转字符串（当然结果也要反转） 原理就是小学乘法，竖式计算，但不需要每次都计算进位，可以统一计算 解决 Tips…]]></description><link>https://mskf.work//algorithm/big-number-multiply</link><guid isPermaLink="false">https://mskf.work//algorithm/big-number-multiply</guid><category><![CDATA[中文]]></category><category><![CDATA[algorithm]]></category><category><![CDATA[math]]></category><category><![CDATA[string]]></category><pubDate>Tue, 22 Oct 2019 04:00:00 GMT</pubDate><content:encoded/><author>gattonero1052@example.com</author></item><item><title><![CDATA[Python Implementation of Koch Snowflake]]></title><description><![CDATA[Koch Curve（Koch Snowflake）
 https://www.geeksforgeeks.org/koch-curve-koch-snowflake/ 简介： 科赫雪花（科赫曲线）是最早发现的分形曲线之一，由瑞典科学家 Helge von Koch…]]></description><link>https://mskf.work//algorithm/python-implementation-of-koch-snowflake</link><guid isPermaLink="false">https://mskf.work//algorithm/python-implementation-of-koch-snowflake</guid><category><![CDATA[中文]]></category><category><![CDATA[algorithm]]></category><category><![CDATA[python]]></category><pubDate>Tue, 22 Oct 2019 04:00:00 GMT</pubDate><content:encoded/><author>gattonero1052@example.com</author></item><item><title><![CDATA[Find integer x,y for ax + by = c]]></title><description><![CDATA[问题 求线性同余方程ax+by=c的整数解 思路 首先介绍下欧几里得算法的原理，众所周知，欧几里得算法是辗转相除法，这里给出证明： 假设a>b，证明 gcd(a,b) = gcd(a mod b,b)
设a=bk+c，c=a mod b
如果D=gcd(b,c)>gcd(a,b…]]></description><link>https://mskf.work//algorithm/find-integer-x-y-for-ax-by-c</link><guid isPermaLink="false">https://mskf.work//algorithm/find-integer-x-y-for-ax-by-c</guid><category><![CDATA[中文]]></category><category><![CDATA[algorithm]]></category><category><![CDATA[math]]></category><pubDate>Tue, 22 Oct 2019 04:00:00 GMT</pubDate><content:encoded/><author>gattonero1052@example.com</author></item><item><title><![CDATA[Linked List Cycle]]></title><description><![CDATA[问题 判断链表中是否有环，如果有，找出链表中环的起始节点 解决 首先找出环的话可以用快慢节点法，快节点的速度是2，慢节点是1
因为两个节点进入环后，快节点会以2-1=…]]></description><link>https://mskf.work//algorithm/linked-list-cycle</link><guid isPermaLink="false">https://mskf.work//algorithm/linked-list-cycle</guid><category><![CDATA[中文]]></category><category><![CDATA[algorithm]]></category><category><![CDATA[linkedlist]]></category><pubDate>Tue, 22 Oct 2019 04:00:00 GMT</pubDate><content:encoded/><author>gattonero1052@example.com</author></item><item><title><![CDATA[Regular Expression For Multiple of 3]]></title><description><![CDATA[问题 使用正则判断n能否被3整除 思路 根据整除性构建DFA（确定有限自动状态机），再根据DFA构建正则（ Kleen算法 ） 解决 我们从高位读取字符串，并将余数作为状态，有如下状态转移表：
X |'0''1'
0 | 0  1
1 | 2  0
2 | 1  2
（X…]]></description><link>https://mskf.work//algorithm/regular-expression-for-multiple-of-3</link><guid isPermaLink="false">https://mskf.work//algorithm/regular-expression-for-multiple-of-3</guid><category><![CDATA[中文]]></category><category><![CDATA[algorithm]]></category><category><![CDATA[regular-expression]]></category><category><![CDATA[DFA]]></category><pubDate>Tue, 22 Oct 2019 04:00:00 GMT</pubDate><content:encoded/><author>gattonero1052@example.com</author></item><item><title><![CDATA[Swim in Rising Water]]></title><description><![CDATA[Swim in Rising Water 问题 假设方阵中每个点都标有权值，问题是求方阵中两点之间的路径中所有点权值最大值的最小值 比如2x2矩阵一共有两条路径，第一条路径中两个点权值是1,3,2最大值为3，第二条路径中两个点权值1,2,2是最大值为2，那么结果就是…]]></description><link>https://mskf.work//algorithm/swim-in-rising-water</link><guid isPermaLink="false">https://mskf.work//algorithm/swim-in-rising-water</guid><category><![CDATA[中文]]></category><category><![CDATA[algorithm]]></category><category><![CDATA[greedy]]></category><pubDate>Tue, 22 Oct 2019 04:00:00 GMT</pubDate><content:encoded/><author>gattonero1052@example.com</author></item><item><title><![CDATA[Combinations and Permutations]]></title><description><![CDATA[问题 排列（Permutation）：求1,2,3...n的不同排列方式（n!） 思路 普通的排列问题，在python…]]></description><link>https://mskf.work//algorithm/combinations-and-permutations</link><guid isPermaLink="false">https://mskf.work//algorithm/combinations-and-permutations</guid><category><![CDATA[中文]]></category><category><![CDATA[algorithm]]></category><category><![CDATA[combination]]></category><category><![CDATA[permutation]]></category><category><![CDATA[bitwise]]></category><pubDate>Sun, 20 Oct 2019 04:00:00 GMT</pubDate><content:encoded/><author>gattonero1052@example.com</author></item><item><title><![CDATA[Reaching Points]]></title><description><![CDATA[Reaching Points 问题 如果给出一个点 (x,y)，可以选择下一个点的坐标 (x+y,y)，或者(x,x+y)，那么，给出一个起点 (sx,sy)，和终点(tx,ty)，能否通过这样的变化，从起点到达终点 解决方案 选择最快的解决方案：这里看上去是个正向dp…]]></description><link>https://mskf.work//algorithm/reaching-points</link><guid isPermaLink="false">https://mskf.work//algorithm/reaching-points</guid><category><![CDATA[中文]]></category><category><![CDATA[algorithm]]></category><category><![CDATA[dynamic-programming]]></category><pubDate>Sun, 20 Oct 2019 04:00:00 GMT</pubDate><content:encoded/><author>gattonero1052@example.com</author></item><item><title><![CDATA[Max Chunks To Make Sorted II]]></title><description><![CDATA[Max Chunks To Make Sorted II 问题 给定一个允许出现重复元素的数组，判断最多可以分成多少段，使得段与段之间都是有序的 解决 思路 1：多次遍历 考虑到给出的数据的范围，这里时间复杂度应该控制在O(N…]]></description><link>https://mskf.work//algorithm/max-chunks-to-make-sorted-ii</link><guid isPermaLink="false">https://mskf.work//algorithm/max-chunks-to-make-sorted-ii</guid><category><![CDATA[中文]]></category><category><![CDATA[algorithm]]></category><category><![CDATA[array]]></category><pubDate>Sat, 05 Oct 2019 04:00:00 GMT</pubDate><content:encoded/><author>gattonero1052@example.com</author></item><item><title><![CDATA[Regular Expression Matching]]></title><description><![CDATA[Regular Expression Matching 问题 用包含*和.这两个正则符号的正则表达式来匹配字符串 解决 思路：贪心匹配+回溯，这里如果不采用贪心的方法也是可以AC…]]></description><link>https://mskf.work//algorithm/regular-expression-matching</link><guid isPermaLink="false">https://mskf.work//algorithm/regular-expression-matching</guid><category><![CDATA[中文]]></category><category><![CDATA[algorithm]]></category><category><![CDATA[string]]></category><pubDate>Sat, 05 Oct 2019 04:00:00 GMT</pubDate><content:encoded/><author>gattonero1052@example.com</author></item><item><title><![CDATA[Java Multi Thread Synchronize]]></title><description><![CDATA[…]]></description><link>https://mskf.work//Java/java-multi-thread-synchronize</link><guid isPermaLink="false">https://mskf.work//Java/java-multi-thread-synchronize</guid><category><![CDATA[中文]]></category><category><![CDATA[Java]]></category><category><![CDATA[multi thread]]></category><category><![CDATA[synchronize]]></category><pubDate>Fri, 04 Oct 2019 04:00:00 GMT</pubDate><content:encoded/><author>gattonero1052@example.com</author></item><item><title><![CDATA[Java Multi Thread Basic]]></title><description><![CDATA[JMM（Java内存模型） Java内存模型是一种逻辑模型，是一组预定规范，定义了每个变量的访问方式，简要运行方式如下 Java内存区域，描述了Java内存的物理分布 JMM分为主内存和工作内存（栈空间），JVM会为每一个线程分配一个工作内存，Java…]]></description><link>https://mskf.work//Java/java-multi-thread-basic</link><guid isPermaLink="false">https://mskf.work//Java/java-multi-thread-basic</guid><category><![CDATA[中文]]></category><category><![CDATA[Java]]></category><category><![CDATA[multi thread]]></category><category><![CDATA[basic]]></category><pubDate>Sun, 07 Jul 2019 04:00:00 GMT</pubDate><content:encoded/><author>gattonero1052@example.com</author></item><item><title><![CDATA[Java Multi Thread Utils]]></title><description><![CDATA[notify wait wait()、notify()和notifyAll()是Object类中的native final方法（除重载），这两个方法是为了解决多线程环境下的竞态环境，必须在同步方法块内调用 notify,notifyAll…]]></description><link>https://mskf.work//Java/java-multi-thread-utils</link><guid isPermaLink="false">https://mskf.work//Java/java-multi-thread-utils</guid><category><![CDATA[中文]]></category><category><![CDATA[Java]]></category><category><![CDATA[multi thread]]></category><category><![CDATA[java util]]></category><category><![CDATA[jdk]]></category><pubDate>Sun, 07 Jul 2019 04:00:00 GMT</pubDate><content:encoded/><author>gattonero1052@example.com</author></item><item><title><![CDATA[Largest Component Size By Common Factor]]></title><description><![CDATA[问题 无向图中，顶点是数字，两个数字的最大公因子大于1时有边，求连通分量 思路 不能直接dfs，考虑接近dfs的另一种算法，并查集
当然，如果直接把数据放在并查集里，并不会降低时间复杂度（实质上依然是两两比较，O(log2(n)*n^…]]></description><link>https://mskf.work//algorithm/largest-component-size-by-common-factor</link><guid isPermaLink="false">https://mskf.work//algorithm/largest-component-size-by-common-factor</guid><category><![CDATA[中文]]></category><category><![CDATA[algorithm]]></category><category><![CDATA[graph]]></category><pubDate>Sat, 15 Jun 2019 04:00:00 GMT</pubDate><content:encoded/><author>gattonero1052@example.com</author></item><item><title><![CDATA[Champagne Tower]]></title><description><![CDATA[Champagne Tower 问题 从一个香槟塔的顶端注入香槟，给出注入香槟的数量，求具体位置上的杯子中香槟的量 解决 模拟注入过程，这里其实如果忽略题中给出的众多条件和状态，反而更容易求解 query_row 和 query_glass…]]></description><link>https://mskf.work//algorithm/champagne-tower</link><guid isPermaLink="false">https://mskf.work//algorithm/champagne-tower</guid><category><![CDATA[中文]]></category><category><![CDATA[algorithm]]></category><category><![CDATA[simulate]]></category><pubDate>Mon, 10 Jun 2019 04:00:00 GMT</pubDate><content:encoded/><author>gattonero1052@example.com</author></item><item><title><![CDATA[Check Completeness Of A Binary Tree]]></title><description><![CDATA[问题 判断一棵树是否是完全二叉树 思路 观察测试数据
 1,2,3,4,5,6 1,2,3,4,5,null,7 1,2,3,4,5,null…]]></description><link>https://mskf.work//algorithm/check-completeness-of-a-binary-tree</link><guid isPermaLink="false">https://mskf.work//algorithm/check-completeness-of-a-binary-tree</guid><category><![CDATA[中文]]></category><category><![CDATA[algorithm]]></category><category><![CDATA[tree]]></category><pubDate>Sun, 10 Mar 2019 05:00:00 GMT</pubDate><content:encoded/><author>gattonero1052@example.com</author></item><item><title><![CDATA[Majority Element]]></title><description><![CDATA[问题： 给定一个n元素数组，求出现次数最大的元素（即Majority Element），并且数组保证该元素出现的次数一定大于⌊ n/2 ⌋ 思路： 空间复杂度大于O(1)或者时间复杂度大于O(n)的就不给了，介绍一个空间O(1)时间O(n)的算法 对于数组an…]]></description><link>https://mskf.work//algorithm/majority-element</link><guid isPermaLink="false">https://mskf.work//algorithm/majority-element</guid><category><![CDATA[中文]]></category><category><![CDATA[algorithm]]></category><category><![CDATA[array]]></category><category><![CDATA[linear time]]></category><pubDate>Fri, 08 Mar 2019 05:00:00 GMT</pubDate><content:encoded/><author>gattonero1052@example.com</author></item><item><title><![CDATA[Longest Palindrome Substring]]></title><description><![CDATA[问题 求最长回文子串 思路 如果考虑O(n)的动态规划，比如用f(i)来代表以当前位置为结尾的回文子串的最大长度，会遇到一个问题，就是说f(i)不仅仅取决于f(i-1)，有可能取决于i-1位置上回文子串的次最大长度等等。比如这个字符串 bananas，下标i从0开始的话，f(…]]></description><link>https://mskf.work//algorithm/longest-palindrome-substring</link><guid isPermaLink="false">https://mskf.work//algorithm/longest-palindrome-substring</guid><category><![CDATA[中文]]></category><category><![CDATA[algorithm]]></category><category><![CDATA[string]]></category><pubDate>Mon, 04 Mar 2019 05:00:00 GMT</pubDate><content:encoded/><author>gattonero1052@example.com</author></item><item><title><![CDATA[Random project 4 With Super Long Title Phase One]]></title><description><![CDATA[Artificem honorati ore temperat Lycus quam antiquum Mendaci pinu ipsi nunc Lorem markdownum supplex. Care ferre nos praemia detestatur…]]></description><link>https://mskf.work//02-03-2017/random-project-4-with-super-long-title-phase-one</link><guid isPermaLink="false">https://mskf.work//02-03-2017/random-project-4-with-super-long-title-phase-one</guid><category><![CDATA[say hi]]></category><pubDate>Wed, 20 Mar 2002 05:00:00 GMT</pubDate><content:encoded/><author>gattonero1052@example.com</author></item><item><title><![CDATA[Big Test]]></title><description><![CDATA[NOTE: This "post" is based on  Markdown Cheatsheet  and is meant to test styling of Markdown generated documents. This is intended as a…]]></description><link>https://mskf.work/Big-Sample_Test</link><guid isPermaLink="false">https://mskf.work/Big-Sample_Test</guid><category><![CDATA[test]]></category><category><![CDATA[huge]]></category><pubDate>Tue, 20 Mar 2001 05:00:00 GMT</pubDate><content:encoded/><author>gattonero1052@example.com</author></item></channel></rss>