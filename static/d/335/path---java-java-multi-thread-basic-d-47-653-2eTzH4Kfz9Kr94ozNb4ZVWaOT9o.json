{"data":{"markdownRemark":{"html":"<h3 id=\"jmm（java内存模型）\"><a href=\"#jmm%EF%BC%88java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%EF%BC%89\" aria-label=\"jmm（java内存模型） permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>JMM（Java内存模型）</h3>\n<ul>\n<li>Java内存模型是一种逻辑模型，是一组预定规范，定义了每个变量的访问方式，简要运行方式如下</li>\n<li>\n<p>Java内存区域，描述了Java内存的物理分布</p>\n<blockquote>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/4655525-b77986e96850367e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Java内存区域\"></p>\n</blockquote>\n</li>\n</ul>\n<blockquote>\n<p>JMM分为主内存和工作内存（栈空间），JVM会为每一个线程分配一个工作内存，Java中所有的实例对象都存在主存中，主存对所有线程共享，但线程不能直接操作主存，只能先进行拷贝，操作完毕后再存进主存中。工作内存是私有的，存有主存数据的副本，线程间的通信必须通过主存来进行</p>\n</blockquote>\n<h3 id=\"jmm的数据存储\"><a href=\"#jmm%E7%9A%84%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8\" aria-label=\"jmm的数据存储 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>JMM的数据存储</h3>\n<p>方法中的基本数据类型存储在工作内存的栈帧中，对象实例的引用也存储在栈帧中，但值存在主存中，除此之外，例如成员变量，静态变量等都存在主存中</p>\n<h3 id=\"jmm保证线程安全的三个特性\"><a href=\"#jmm%E4%BF%9D%E8%AF%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E4%B8%89%E4%B8%AA%E7%89%B9%E6%80%A7\" aria-label=\"jmm保证线程安全的三个特性 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>JMM保证线程安全的三个特性</h3>\n<ul>\n<li>\n<p>原子性：指不可中断的操作，理论上对于32位操作系统来说，long和double数据的读取是非原子操作</p>\n</li>\n<li>\n<p>可见性：一个线程间共享的变量可见，指当一个线程修改了该共享变量的值，其他线程是否能立刻获取到这一次的修改。对于单线程来说，这个问题是不存在的，而对于多线程来说，如果存在工作内存和主存的同步延迟，就会出现一个线程修改变量之后，另一个线程仍然读取修改前主存中的变量值</p>\n</li>\n<li>\n<p>有序性：对于多线程，编译成机器码后会出现指令重排的现象，对于一个线程来说，每条指令的执行顺序是固定的，但对于多个线程来说，指令的执行顺序是不固定的</p>\n<h3 id=\"jmm提供的线程安全解决方案\"><a href=\"#jmm%E6%8F%90%E4%BE%9B%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88\" aria-label=\"jmm提供的线程安全解决方案 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>JMM提供的线程安全解决方案</h3>\n</li>\n<li>\n<p>对数据的原子性操作，可以使用java.util.concurrent.atomic.*这个包，对代码块的原子性操作，可以使用synchronized关键字或者重入锁(ReentrantLock)</p>\n</li>\n<li>\n<p>happens-before原则</p>\n<blockquote>\n<p>一套辅助规则保证程序执行的原子性，可见性和有序性</p>\n</blockquote>\n</li>\n<li>\n<p>同一线程中，代码一定按顺序执行</p>\n</li>\n<li>\n<p>同一个锁，先进行解锁才能加锁（也就是说加锁和解锁一定是轮流执行）</p>\n</li>\n<li>\n<p>对于volatile变量，强制从主存中读取，并且在改变后强制刷新到主存</p>\n</li>\n<li>\n<p>线程启动规则：线程的start()方法先于它的每一个动作</p>\n</li>\n<li>\n<p>线程终止规则：线程的终止在所有动作之后（例如线程A中执行了线程B.join()，那么B中所有的对共享变量的操作结果，都能在B.join()结束后被A读取到）</p>\n</li>\n<li>\n<p>线程中断规则：interrupt()方法先执行，Thread.interrupted()再返回true</p>\n</li>\n<li>\n<p>对象终结规则：对象的构造函数先于finalize()方法（但一般不会Override finalize()方法）</p>\n</li>\n</ul>\n<h3 id=\"新建线程的三种方式\"><a href=\"#%E6%96%B0%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F\" aria-label=\"新建线程的三种方式 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>新建线程的三种方式</h3>\n<ul>\n<li>继承Thread类</li>\n<li>实现Runnable接口（lambda，匿名内部类等）</li>\n<li>实现Callable接口</li>\n</ul>\n<h3 id=\"线程状态\"><a href=\"#%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81\" aria-label=\"线程状态 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>线程状态</h3>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>状态</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>NEW</td>\n<td>构建完毕，但是没有start()</td>\n</tr>\n<tr>\n<td>RUNNABLE</td>\n<td>运行中，包括就绪和运行状态</td>\n</tr>\n<tr>\n<td>BLOCKED</td>\n<td>线程阻塞，被锁住</td>\n</tr>\n<tr>\n<td>WAITING</td>\n<td>线程进入等待状态，需要其他线程通知或中断</td>\n</tr>\n<tr>\n<td>TIME_WAITING</td>\n<td>超时等待，可以在指定时间自行改变</td>\n</tr>\n<tr>\n<td>TERMINATED</td>\n<td>线程终止，已执行完毕</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"线程操作\"><a href=\"#%E7%BA%BF%E7%A8%8B%E6%93%8D%E4%BD%9C\" aria-label=\"线程操作 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>线程操作</h3>\n<ul>\n<li>interrupt 不改变线程的状态情况下实现线程间的交互，可以用于线程结束时清理资源</li>\n<li>join 将另一个线程加入当前线程，同步执行</li>\n<li>sleep 让线程按指定时间休眠，注意和Object.wait()的比较</li>\n<li>yield 让当前线程让出cpu，注意与sleep比较</li>\n</ul>\n<h4 id=\"interrupt机制\"><a href=\"#interrupt%E6%9C%BA%E5%88%B6\" aria-label=\"interrupt机制 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>interrupt机制</h4>\n<p>当调用thread.interrupt()时</p>\n<ol>\n<li>线程在sleep, wait, join, 方法会被唤醒，并且需要对interruptedException进行处理</li>\n<li>线程运行（RUNNABLE）中，会设置interrupt标志位，可通过isInterrupted()进行查看并进行处理</li>\n</ol>\n<h3 id=\"守护线程\"><a href=\"#%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B\" aria-label=\"守护线程 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>守护线程</h3>\n<p>例如GC，JIT线程就属于守护线程，可以通过setDaemon设置，当虚拟机只有守护线程时，线程会执行退出</p>\n<h3 id=\"tips\"><a href=\"#tips\" aria-label=\"tips permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Tips</h3>\n<ul>\n<li>yield VS sleep </li>\n<li>yield只是使当前线程让出cpu，不一定会切换到其他线程</li>\n<li>yield让出cpu后，只有与当前线程具有相同优先级的线程有竞争权，而sleep交出的时间片，其他线程都可以竞争</li>\n<li>编译器重排和处理器指令重排：</li>\n<li>简单地说，比如线程A有指令A1,A2,A3，线程B有指令B1,B2,B3，A1A2A3B1B2B3，A1B1B2B3A2A3等等都是可能出现的指令顺序</li>\n<li>\n<p>赋值语句的重排属于编译器重排，而机器码指令的重排数据处理器重排</p>\n<h3 id=\"ref\"><a href=\"#ref\" aria-label=\"ref permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>ref</h3>\n<p><a href=\"https://www.jianshu.com/p/f65ea68a4a7f\">https://www.jianshu.com/p/f65ea68a4a7f</a>\n<a href=\"https://blog.csdn.net/javazejian/article/details/72772461\">https://blog.csdn.net/javazejian/article/details/72772461</a>\n<a href=\"https://blog.csdn.net/javazejian/article/details/72828483\">https://blog.csdn.net/javazejian/article/details/72828483</a></p>\n</li>\n</ul>","timeToRead":3,"excerpt":"JMM（Java内存模型）Java内存模型是一种逻辑模型，是一组预定规范，定义了每个变量的访问方式，简要运行方式如下Java内存区域，描述了Java内存的物理分布Java内存区域JMM分为主内存和工作内存（栈空间），JVM会为每一个线程分配一个工作内存，Java…","frontmatter":{"title":"Java Multi Thread Basic","cover":"","date":"2019/7/7","category":"Java","tags":["中文","Java","multi thread","basic"]},"fields":{"slug":"/Java/java-multi-thread-basic","date":"2019-07-07T04:00:00.000Z"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/Java/java-multi-thread-basic","nexttitle":"","nextslug":"","prevtitle":"Java Multi Thread Synchronize","prevslug":"/Java/java-multi-thread-synchronize"}}