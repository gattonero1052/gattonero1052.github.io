{"data":{"allMarkdownRemark":{"totalCount":18,"edges":[{"node":{"fields":{"slug":"/algorithm/big-number-multiply","date":"2019-10-22T04:00:00.000Z"},"excerpt":"问题适用于1000位以内数的乘法思路注意两点：数字是通过字符串传过来的，字符串的低位反而是数字的高位，所以我们要从数字的低位开始计算的话，必须反转字符串（当然结果也要反转）原理就是小学乘法，竖式计算，但不需要每次都计算进位，可以统一计算解决Tips…","timeToRead":1,"frontmatter":{"title":"Big Number Multiply","tags":["中文","algorithm","math","string"],"cover":"","date":"2019/10/22"}}},{"node":{"fields":{"slug":"/algorithm/find-integer-x-y-for-ax-by-c","date":"2019-10-22T04:00:00.000Z"},"excerpt":"问题求线性同余方程ax+by=c的整数解思路首先介绍下欧几里得算法的原理，众所周知，欧几里得算法是辗转相除法，这里给出证明：假设a>b，证明 gcd(a,b) = gcd(a mod b,b)\n设a=bk+c，c=a mod b\n如果D=gcd(b,c)>gcd(a,b…","timeToRead":1,"frontmatter":{"title":"Find integer x,y for ax + by = c","tags":["中文","algorithm","math"],"cover":"","date":"2019/10/22"}}},{"node":{"fields":{"slug":"/algorithm/linked-list-cycle","date":"2019-10-22T04:00:00.000Z"},"excerpt":"问题判断链表中是否有环，如果有，找出链表中环的起始节点解决首先找出环的话可以用快慢节点法，快节点的速度是2，慢节点是1\n因为两个节点进入环后，快节点会以2-1=…","timeToRead":1,"frontmatter":{"title":"Linked List Cycle","tags":["中文","algorithm","linkedlist"],"cover":"","date":"2019/10/22"}}},{"node":{"fields":{"slug":"/algorithm/regular-expression-for-multiple-of-3","date":"2019-10-22T04:00:00.000Z"},"excerpt":"问题使用正则判断n能否被3整除思路根据整除性构建DFA（确定有限自动状态机），再根据DFA构建正则（Kleen算法）解决我们从高位读取字符串，并将余数作为状态，有如下状态转移表：\nX |'0''1'\n0 | 0  1\n1 | 2  0\n2 | 1  2\n（X…","timeToRead":1,"frontmatter":{"title":"Regular Expression For Multiple of 3","tags":["中文","algorithm","regular-expression","DFA"],"cover":"","date":"2019/10/22"}}},{"node":{"fields":{"slug":"/algorithm/swim-in-rising-water","date":"2019-10-22T04:00:00.000Z"},"excerpt":"Swim in Rising Water问题假设方阵中每个点都标有权值，问题是求方阵中两点之间的路径中所有点权值最大值的最小值比如2x2矩阵一共有两条路径，第一条路径中两个点权值是1,3,2最大值为3，第二条路径中两个点权值1,2,2是最大值为2，那么结果就是2解决想到用dp…","timeToRead":1,"frontmatter":{"title":"Swim in Rising Water","tags":["中文","algorithm","greedy"],"cover":"","date":"2019/10/22"}}},{"node":{"fields":{"slug":"/algorithm/python-implementation-of-koch-snowflake","date":"2019-10-22T04:00:00.000Z"},"excerpt":"Koch Curve（Koch Snowflake）\nhttps://www.geeksforgeeks.org/koch-curve-koch-snowflake/简介：科赫雪花（科赫曲线）是最早发现的分形曲线之一，由瑞典科学家 Helge von Koch…","timeToRead":1,"frontmatter":{"title":"Python Implementation of Koch Snowflake","tags":["中文","algorithm","python"],"cover":"","date":"2019/10/22"}}},{"node":{"fields":{"slug":"/algorithm/combinations-and-permutations","date":"2019-10-20T04:00:00.000Z"},"excerpt":"问题排列（Permutation）：求1,2,3...n的不同排列方式（n!）思路普通的排列问题，在python…","timeToRead":2,"frontmatter":{"title":"Combinations and Permutations","tags":["中文","algorithm","combination","permutation","bitwise"],"cover":"","date":"2019/10/20"}}},{"node":{"fields":{"slug":"/algorithm/reaching-points","date":"2019-10-20T04:00:00.000Z"},"excerpt":"Reaching Points问题如果给出一个点 (x,y)，可以选择下一个点的坐标 (x+y,y)，或者(x,x+y)，那么，给出一个起点 (sx,sy)，和终点(tx,ty…","timeToRead":1,"frontmatter":{"title":"Reaching Points","tags":["中文","algorithm","dynamic-programming"],"cover":"","date":"2019/10/20"}}},{"node":{"fields":{"slug":"/algorithm/max-chunks-to-make-sorted-ii","date":"2019-10-05T04:00:00.000Z"},"excerpt":"Max Chunks To Make Sorted II问题给定一个允许出现重复元素的数组，判断最多可以分成多少段，使得段与段之间都是有序的解决思路 1：多次遍历考虑到给出的数据的范围，这里时间复杂度应该控制在O(N…","timeToRead":1,"frontmatter":{"title":"Max Chunks To Make Sorted II","tags":["中文","algorithm","array"],"cover":"","date":"2019/10/5"}}},{"node":{"fields":{"slug":"/algorithm/regular-expression-matching","date":"2019-10-05T04:00:00.000Z"},"excerpt":"Regular Expression Matching问题用包含*和.这两个正则符号的正则表达式来匹配字符串解决思路：贪心匹配+回溯，这里如果不采用贪心的方法也是可以AC…","timeToRead":1,"frontmatter":{"title":"Regular Expression Matching","tags":["中文","algorithm","string"],"cover":"","date":"2019/10/5"}}},{"node":{"fields":{"slug":"/Java/java-multi-thread-synchronize","date":"2019-10-04T04:00:00.000Z"},"excerpt":"…","timeToRead":1,"frontmatter":{"title":"Java Multi Thread Synchronize","tags":["中文","Java","multi thread","synchronize"],"cover":"","date":"2019/10/4"}}},{"node":{"fields":{"slug":"/Java/java-multi-thread-basic","date":"2019-07-07T04:00:00.000Z"},"excerpt":"JMM（Java内存模型）Java内存模型是一种逻辑模型，是一组预定规范，定义了每个变量的访问方式，简要运行方式如下Java内存区域，描述了Java内存的物理分布Java内存区域JMM分为主内存和工作内存（栈空间），JVM会为每一个线程分配一个工作内存，Java…","timeToRead":3,"frontmatter":{"title":"Java Multi Thread Basic","tags":["中文","Java","multi thread","basic"],"cover":"","date":"2019/7/7"}}},{"node":{"fields":{"slug":"/Java/java-multi-thread-utils","date":"2019-07-07T04:00:00.000Z"},"excerpt":"notify waitwait()、notify()和notifyAll()是Object类中的native final方法（除重载），这两个方法是为了解决多线程环境下的竞态环境，必须在同步方法块内调用notify,notifyAll…","timeToRead":10,"frontmatter":{"title":"Java Multi Thread Utils","tags":["中文","Java","multi thread","java util","jdk"],"cover":"https://unsplash.it/1152/300/?random?SuperLong","date":"2019/07/07"}}},{"node":{"fields":{"slug":"/algorithm/largest-component-size-by-common-factor","date":"2019-06-15T04:00:00.000Z"},"excerpt":"问题无向图中，顶点是数字，两个数字的最大公因子大于1时有边，求连通分量思路不能直接dfs，考虑接近dfs的另一种算法，并查集\n当然，如果直接把数据放在并查集里，并不会降低时间复杂度（实质上依然是两两比较，O(log2(n)*n^…","timeToRead":1,"frontmatter":{"title":"Largest Component Size By Common Factor","tags":["中文","algorithm","graph"],"cover":"","date":"2019/6/15"}}},{"node":{"fields":{"slug":"/algorithm/champagne-tower","date":"2019-06-10T04:00:00.000Z"},"excerpt":"Champagne Tower问题从一个香槟塔的顶端注入香槟，给出注入香槟的数量，求具体位置上的杯子中香槟的量解决模拟注入过程，这里其实如果忽略题中给出的众多条件和状态，反而更容易求解queryrow 和 queryglass 的范围并不大，如果用二维数组模拟，可以做到O…","timeToRead":1,"frontmatter":{"title":"Champagne Tower","tags":["中文","algorithm","simulate"],"cover":"","date":"2019/6/10"}}},{"node":{"fields":{"slug":"/algorithm/check-completeness-of-a-binary-tree","date":"2019-03-10T05:00:00.000Z"},"excerpt":"问题判断一棵树是否是完全二叉树思路观察测试数据\n1,2,3,4,5,61,2,3,4,5,null,71,2,3,4,5,null…","timeToRead":1,"frontmatter":{"title":"Check Completeness Of A Binary Tree","tags":["中文","algorithm","tree"],"cover":"","date":"2019/3/10"}}},{"node":{"fields":{"slug":"/algorithm/majority-element","date":"2019-03-08T05:00:00.000Z"},"excerpt":"问题：给定一个n元素数组，求出现次数最大的元素（即Majority Element），并且数组保证该元素出现的次数一定大于⌊ n/2 ⌋思路：空间复杂度大于O(1)或者时间复杂度大于O(n)的就不给了，介绍一个空间O(1)时间O(n)的算法对于数组an，注意到Majority…","timeToRead":1,"frontmatter":{"title":"Majority Element","tags":["中文","algorithm","array","linear time"],"cover":"","date":"2019/3/8"}}},{"node":{"fields":{"slug":"/algorithm/longest-palindrome-substring","date":"2019-03-04T05:00:00.000Z"},"excerpt":"问题求最长回文子串思路如果考虑O(n)的动态规划，比如用f(i)来代表以当前位置为结尾的回文子串的最大长度，会遇到一个问题，就是说f(i)不仅仅取决于f(i-1)，有可能取决于i-1位置上回文子串的次最大长度等等。比如这个字符串 bananas，下标i从0开始的话，f(3)=…","timeToRead":2,"frontmatter":{"title":"Longest Palindrome Substring","tags":["中文","algorithm","string"],"cover":"","date":"2019/3/4"}}}]}},"pageContext":{"isCreatedByStatefulCreatePages":false,"tag":"中文"}}