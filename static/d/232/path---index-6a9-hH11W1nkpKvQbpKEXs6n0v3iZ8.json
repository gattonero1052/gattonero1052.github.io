{"data":{"allMarkdownRemark":{"edges":[{"node":{"fields":{"slug":"/Java/multiutil","date":null},"excerpt":"notify waitwait()、notify()和notifyAll()是Object类中的native final方法（除重载），这两个方法是为了解决多线程环境下的竞态环境，必须在同步方法块内调用notify,notifyAll…","timeToRead":10,"rawMarkdownBody":"### notify wait\r\nwait()、notify()和notifyAll()是Object类中的native final方法（除重载），这两个方法是为了解决多线程环境下的竞态环境，必须在同步方法块内调用\r\n\r\n- notify,notifyAll 唤起其他等待锁的线程，但并不会立刻切换到其他线程，而是等到执行完同步代码块之后再进行切换，使用notify会唤起最先等待的线程，notifyAll会唤起所有等待的线程\r\n\r\n- wait 使当前线程阻塞，释放所持有的锁（不必等到同步代码块结束）\r\n\r\n- 不建议直接使用notify wait进行多线程编程\r\n\r\n模拟使用notify的场景：两个线程竞争同一资源\r\n```java\r\n\r\n//two threads competing for one resource\r\npublic class CompetingThread {\r\n    Thread[] threads;\r\n\r\n    CompetingThread(Thread[] threads){\r\n        this.threads= threads;\r\n    }\r\n\r\n    public void get() {\r\n        Thread t1 = threads[0], t2 = threads[1];\r\n        System.out.println(\"Ready to Get\");\r\n        synchronized (this){\r\n            System.out.println(Thread.currentThread().getName()+\" Got the lock\");\r\n\r\n            System.out.println(\"Now, \"+t1.getName()+\" is \"+t1.getState()+\", \"+t2.getName()+\" is \"+t2.getState());\r\n            System.out.println(\"notify() to release the lock after all done\");\r\n            System.out.println(\"Do sth. before notify is just the same as after\");\r\n            notify();\r\n            System.out.println(\"Do sth. after notify is just the same as before\");\r\n            System.out.println(Thread.currentThread().getName()+\" is done.\");\r\n        }\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n        Thread[] threads = new Thread[2];\r\n        CompetingThread competingThread = new CompetingThread(threads);\r\n        threads[0] = new Thread(()->competingThread.get());\r\n        threads[1] = new Thread(()->competingThread.get());\r\n        threads[0].start();\r\n        threads[1].start();\r\n    }\r\n}\r\n\r\n```\r\n\r\n输出\r\n\r\n```text\r\n//output\r\n\r\nReady to Get\r\nReady to Get\r\nThread-0 Got the lock\r\nNow, Thread-0 is RUNNABLE, Thread-1 is BLOCKED\r\nnotify() to release the lock after all done\r\nDo sth. before notify is just the same as after\r\nDo sth. after notify is just the same as before\r\nThread-0 is done.\r\nThread-1 Got the lock\r\nNow, Thread-0 is TERMINATED, Thread-1 is RUNNABLE\r\nnotify() to release the lock after all done\r\nDo sth. before notify is just the same as after\r\nDo sth. after notify is just the same as before\r\nThread-1 is done.\r\n```\r\n模拟使用wait和notify(notifyAll)的场景：顾客在餐厅点餐，服务员等候（BLOCKING），点餐完毕，顾客等候上菜（wait()），服务员上菜，告知顾客菜来了（notify()）\r\n```java\r\npublic class WaitNotifyExample {\r\n    public static Object menu = new Object();\r\n\r\n    public static void main(String[] args) {\r\n        Thread customer = new Thread() {\r\n            @Override\r\n            public void run() {\r\n                synchronized (menu) {\r\n                    System.out.println(\"Customer: I'm reading menu, please wait\");\r\n                    try {\r\n                        Thread.sleep(1000);\r\n                        System.out.println(\"Customer: These are my orders.(waiting for the meal)\");\r\n                        menu.wait();\r\n                    }catch (InterruptedException e){}\r\n                    System.out.println(\"Customer: Oh, these are my foods!\");\r\n                }\r\n            }\r\n        };\r\n\r\n        Thread waiter = new Thread(){\r\n            @Override\r\n            public void run(){\r\n                System.out.println(\"Waiter: (Waiting for customer's orders)\");\r\n                synchronized (menu){\r\n                    System.out.println(\"Waiter: Gonna prepare you meal, sir.\");\r\n                    try {\r\n                        Thread.sleep(1000);\r\n                        menu.notify();//notifyAll if there are more than 1 customer\r\n                        System.out.println(\"Waiter: Your foods are ready.\");\r\n                    }catch (InterruptedException e){}\r\n                }\r\n            }\r\n        };\r\n\r\n        customer.start();\r\n        waiter.start();\r\n    }\r\n}\r\n```\r\n输出\r\n```text\r\n//output\r\n\r\nCustomer: I'm reading menu, please wait\r\nWaiter: (Waiting for customer's orders)\r\nCustomer: These are my orders.(waiting for the meal)\r\nWaiter: Gonna prepare you meal, sir.\r\nWaiter: Your foods are ready.\r\nCustomer: Oh, these are my foods!\r\n\r\n```\r\n\r\n### CountDownLatch\r\n一个线程安全的倒计时器，在倒计时为0前，令线程等待（getState()：WAITING）\r\n\r\n使用步骤：\r\n- 构造一个容量为10的倒计时器 `CountDownLatch latch = new CountDownLatch(10)`\r\n- 主线程中调用`latch.await()`，等待相关线程进行倒计时\r\n- 不同的线程中调用该倒计时器实例的`latch.countDown()`方法，进行倒计时\r\n- 当latch的倒计时为0时，主线程恢复运行\r\n\r\n### ReentrantLock\r\nReentrantLock(Re-entrantLock)是一个基于AQS（AbstractQueuedSynchronizer）高性能工具，支持线程在未释放锁的情况下重复获取锁\r\n#### API\r\n方法 | 解释\r\n---|---\r\nlock | holdCount+1，并给当前线程加锁\r\nunlock | holdCount-1，holdCount为0时，释放资源\r\ntryLock | 如果资源锁不在其他线程中，返回true，holdCount+1，否则返回false，不过线程并不会阻塞\r\nlockInterruptibly() | 锁空闲的情况下正常获取，但是允许被其他线程的请求中断\r\ngetHoldCount | 获取holdCount，注意如果持有锁的不是本线程，则直接返回0\r\n\r\n#### 原理概述\r\nReentrantLock的可重入功能基于AQS的同步状态：state（可通过getHoldCount获取）。当某一线程获取锁后，holdCount+1，并记录下当前持有锁的线程，再有线程来获取锁时，判断这个线程与持有锁的线程是否是同一个线程，如果是，holdCount+1，如果不是，阻塞线程。\r\n当线程释放锁时，holdCount-1，holdCount为0时，唤醒其他线程，使其重新竞争锁。\r\n\r\n#### 解决问题\r\n\r\n- 解决synchronized在竞争激烈场景下的性能问题\r\n>在锁竞争不激烈的时候，多数情况下锁会停留在偏向锁和轻量级锁阶段,这两个阶段下，synchronized性能很好，但当存在大量线程竞争锁时，可能会膨胀为重量级锁，性能下降，ReentrantLock的性能会优于synchronized。不过在JDK1.6之后，synchronized进行了优化，大多数场景下性能与ReentrantLock所差无几\r\n\r\n- 填补其他synchronized的缺陷\r\n>一旦线程卡在等待锁的阶段，就有可能出现死锁\r\n\r\n>不可响应中断\r\n\r\n>不能尝试获取锁\r\n\r\n#### ReentrantLock VS synchronized\r\n>对多线程操作支持情况和实现方式（如果支持的话）\r\n\r\n项目\\锁 | synchronized | \tReentrantLock\r\n---|---|---\r\n公平性|只支持非公平锁 | 支持公平锁和非公平锁\r\n是否支持尝试获取锁|不支持|支持 tryLock(time, TimeUnit)\r\n是否可响应中断|不支持|支持 lockInterruptibly\r\n等待条件|支持 notify wait | 支持 Condition\r\n\r\n\r\n#### ReentrantLock Example\r\ntryLock，lock，lockInterruptibly的对比测试，runnableWork是一个耗时操作，目的是让线程状态保持在RUNNABLE\r\n```java\r\npublic class ReentrantLockAPI {\r\n    public static void runnableWork(){\r\n        for (int i = 0; i < 1000; i++) {\r\n            for (int j = 0; j < 1000; j++) {\r\n                for (int k = 0; k < 1000; k++) {\r\n\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    public static void lockInterruptibly_tryLock_API(){\r\n        final ReentrantLock lock = new ReentrantLock();\r\n        Thread interruptibleThread = new Thread(()->{\r\n            try {\r\n                runnableWork();\r\n                lock.lockInterruptibly();\r\n                System.out.println(\"ReentrantLock is locked by  \"+Thread.currentThread().getName());\r\n            }catch (InterruptedException e){\r\n                System.out.println(Thread.currentThread().getName()+\" was interrupted while getting lock\");\r\n            }finally {\r\n                if(lock.isHeldByCurrentThread()) {\r\n                    System.out.println(\"ReentrantLock is released by  \"+Thread.currentThread().getName());\r\n                    lock.unlock();\r\n                }\r\n            }\r\n        });\r\n\r\n        Thread uninterruptibleThread = new Thread(()->{\r\n            System.out.println(\"ReentrantLock is locked by  \"+Thread.currentThread().getName());\r\n            try {\r\n                runnableWork();\r\n                lock.lock();\r\n            }catch (Exception e){\r\n                System.out.println(Thread.currentThread().getName()+\" was interrupted.\");\r\n            }finally {\r\n                System.out.println(\"ReentrantLock is released by  \"+Thread.currentThread().getName());\r\n                lock.unlock();\r\n            }\r\n        });\r\n\r\n        Thread interruptThread = new Thread(()->{\r\n            //uninterruptibleThread.interrupt();\r\n            interruptibleThread.interrupt();\r\n        });\r\n\r\n        interruptibleThread.start();\r\n//      uninterruptibleThread.start();\r\n        interruptThread.start();\r\n    }\r\n\r\n    public static void lock_tryLock_API(){\r\n        ReentrantLock lock = new ReentrantLock();\r\n        Thread t1 = new Thread(()->{\r\n            System.out.println(\"ReentrantLock is locked by  \"+Thread.currentThread().getName());\r\n            lock.lock();\r\n            try {\r\n                Thread.sleep(1000);\r\n            }catch (Exception e){}\r\n            System.out.println(\"ReentrantLock is released by  \"+Thread.currentThread().getName());\r\n            lock.unlock();\r\n        });\r\n\r\n        Thread t2 = new Thread(()->{\r\n            try {\r\n                System.out.println(\"Try to get the lock, if not, wait for sometime\");\r\n                boolean res = lock.tryLock(500l, TimeUnit.MILLISECONDS);//if timeout >1000, result will be true, because t1 released the lock after 1000ms\r\n                System.out.println(\"tryLock returns: \"+res+\" ,and \"+Thread.currentThread().getName()+\" is \"+Thread.currentThread().getState());\r\n            } catch (InterruptedException e) { }\r\n        });\r\n\r\n        t1.start();\r\n        t2.start();\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n        lock_tryLock_API();\r\n        lockInterruptibly_tryLock_API();\r\n    }\r\n}\r\n\r\n```\r\n\r\n>lockInterruptibly_tryLock_API\r\n\r\n尝试打断interruptibleThread，输出如下\r\n```java\r\n//output when interrupt interruptibleThread thread\r\n\r\nThread-0 was interrupted while getting lock\r\n```\r\n\r\n尝试打断uninterruptibleThread，输出如下\r\n```java\r\n//output when interrupt uninterruptibleThread thread\r\n\r\nReentrantLock is locked by  Thread-1\r\nReentrantLock is released by  Thread-1\r\n```\r\n>lock_tryLock_API\r\n\r\n调整tryLock的时间，可以观察到给定足够尝试时间的情况下才能获取到锁\r\n```java\r\n//output when tryLock time is NOT enough\r\n\r\nTry to get the lock, if not, wait for sometime\r\nReentrantLock is locked by  Thread-0\r\ntryLock returns: false ,and Thread-1 is RUNNABLE\r\nReentrantLock is released by  Thread-0\r\n\r\n//output when tryLock time is enough\r\nReentrantLock is locked by  Thread-0\r\nTry to get the lock, if not, wait for sometime\r\nReentrantLock is released by  Thread-0\r\ntryLock returns: true ,and Thread-1 is RUNNABLE\r\n\r\n```\r\n使用tryLock解决死锁问题\r\n\r\n一个典型的死锁案例，两个对象锁分别被两个线程持有，两个线程经过一段时间后各请求对方所持有的锁，自然就产生了死锁\r\n```\r\npublic class DeadLock {\r\n\r\n    public static final Object lock1 = new Object();\r\n    public static final Object lock2 = new Object();\r\n\r\n    public static void main(String[] a) {\r\n        Thread t1 = new Thread1();\r\n        Thread t2 = new Thread2();\r\n        t1.start();\r\n        t2.start();\r\n    }\r\n\r\n    private static class Thread1 extends Thread {\r\n\r\n        public void run() {\r\n            synchronized (lock1) {\r\n                try {\r\n                    Thread.sleep(10);\r\n                } catch (InterruptedException ignored) {}\r\n                synchronized (lock2) {\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private static class Thread2 extends Thread {\r\n\r\n        public void run() {\r\n            synchronized (lock2) {\r\n                try {\r\n                    Thread.sleep(10);\r\n                } catch (InterruptedException ignored) {}\r\n                synchronized (lock1) {\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n使用tryLock解决，我们的目的是使两个线程都能获取到两个锁，并且分别处理，那么我们可以把获取锁写在一个逻辑里\r\n```\r\npublic class DeadLock {\r\n\r\n    public static final ReentrantLock reentrantLock1 = new ReentrantLock();\r\n    public static final ReentrantLock reentrantLock2 = new ReentrantLock();\r\n\r\n    private static boolean getLocks(long milliseconds){\r\n        boolean getLock1 = false, getLock2 = false;\r\n        try{\r\n            getLock1 = reentrantLock1.tryLock(milliseconds, TimeUnit.MILLISECONDS);\r\n            getLock2 = reentrantLock2.tryLock(milliseconds,TimeUnit.MILLISECONDS);\r\n        }catch (Exception e){\r\n            e.printStackTrace();\r\n        } finally {\r\n            if(getLock1 && getLock2) return true;\r\n            else if(getLock1) reentrantLock1.unlock();\r\n            else if(getLock2) reentrantLock2.unlock();\r\n            return false;\r\n        }\r\n    }\r\n\r\n    public static void main(String[] a) {\r\n        Thread t1 = new Thread1();\r\n        Thread t2 = new Thread2();\r\n        t1.start();\r\n        t2.start();\r\n    }\r\n\r\n    private static class Thread1 extends Thread {\r\n        public void run() {\r\n            boolean res = getLocks(1000);\r\n            if(res){\r\n                System.out.println(Thread.currentThread().getName()+\" Got lock1?\"+reentrantLock1.isHeldByCurrentThread());\r\n                System.out.println(Thread.currentThread().getName()+\" Got lock2?\"+reentrantLock2.isHeldByCurrentThread());\r\n                try{\r\n                    //..do sth. with locked resources\r\n                    Thread.sleep(100);\r\n                }catch (Exception e){\r\n                   e.printStackTrace();\r\n                } finally {\r\n                    reentrantLock1.unlock();\r\n                    reentrantLock2.unlock();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private static class Thread2 extends Thread {\r\n        public void run() {\r\n            boolean res = getLocks(1000);\r\n            if(res){\r\n                System.out.println(Thread.currentThread().getName()+\" Got lock1?\"+reentrantLock1.isHeldByCurrentThread());\r\n                System.out.println(Thread.currentThread().getName()+\" Got lock2?\"+reentrantLock2.isHeldByCurrentThread());\r\n                try{\r\n                    //..do other things. with locked resources\r\n                    Thread.sleep(100);\r\n                }catch (Exception e){\r\n                    e.printStackTrace();\r\n                } finally {\r\n                    reentrantLock1.unlock();\r\n                    reentrantLock2.unlock();\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n我们模拟两个线程，可以看到输出中，两个线程分别获得了两个锁，从而解决了死锁的问题\r\n```\r\n//output\r\n\r\nThread-1 Got lock1?true\r\nThread-1 Got lock2?true\r\nThread-0 Got lock1?true\r\nThread-0 Got lock2?true\r\n```\r\n\r\n### Condition\r\nCondition对应一个ReentrantLock，在调用时，要求线程持有该ReentrantLock的锁，我们看下Condition类的实例方法：\r\n\r\n#### API\r\n方法名 | 参数 | 返回\r\n---|---|---\r\nawait||void\r\nawaitUninterruptibly||void\r\nawaitNanos|long|void\r\nawait|long,TimeUnit|boolean\r\nawaitUntil|Date|boolean\r\nsignal||void\r\nsignalAll||void\r\n可以看到，实际上主要实现了await和signal这两个功能，await和Object.await类似，给定等待时间，直到被通知，signal和notify类似，signal()唤醒等待在该Condition的线程，signalAll()唤醒所有等待在该Condition的线程\r\n\r\n#### ReentrantLock Condition Example\r\n两个方法分别对应两个示例\r\n\r\n第一个示例中，一个线程通过condition.signalAll唤醒另一个线程，相应的输出和使用方法与synchronized下的Object.notify，Object.await完全一致\r\n\r\n第二个示例中，前3个线程对应一个锁的ConditionA，后3个线程对应同一个锁的ConditionB，最后一个线程唤醒前3个线程，后3个线程在等待时间截止后自动执行，从而实现了线程的分组控制\r\n```java\r\npublic class ReentrantLockConditionAPI {\r\n    public static void singleConditionForThreads(){\r\n        ReentrantLock lock = new ReentrantLock();\r\n        Condition condition = lock.newCondition();\r\n        Thread t1 = new Thread(){\r\n            @Override\r\n            public void run() {\r\n                try {\r\n                    lock.lock();\r\n                    System.out.println(Thread.currentThread().getName()+\" work for 1 second\");\r\n                    Thread.sleep(1000);\r\n                    condition.await();//Must between lock() and unlock()\r\n                    System.out.println(\"Finished, start to wait\");\r\n                    System.out.println(Thread.currentThread().getName()+\" another work for 1 second\");\r\n                    Thread.sleep(1000);\r\n                }catch (Exception e){\r\n                    e.printStackTrace();\r\n                }finally {\r\n                    System.out.println(Thread.currentThread().getName() + \" finished\");\r\n                    lock.unlock();\r\n                }\r\n            }\r\n        };\r\n\r\n        Thread t2 = new Thread(){\r\n            @Override\r\n            public void run() {\r\n                try {\r\n                    Thread.sleep(100);\r\n                    lock.lock();\r\n                    System.out.println(Thread.currentThread().getName()+\" got the lock\");\r\n                    condition.signalAll();\r\n                }catch (Exception e){\r\n                    e.printStackTrace();\r\n                }finally {\r\n                    System.out.println(Thread.currentThread().getName()+\" finished\");\r\n                    lock.unlock();\r\n                }\r\n            }\r\n        };\r\n\r\n        t1.start();\r\n        t2.start();\r\n    }\r\n\r\n    public static void multipleConditionForThreadGroups(){\r\n        ReentrantLock lock = new ReentrantLock();\r\n        Condition conditionA = lock.newCondition();\r\n        Condition conditionB = lock.newCondition();\r\n\r\n        ExecutorService executorService = Executors.newFixedThreadPool(7);\r\n\r\n        //conditionA\r\n        for (int i = 0; i < 3; i++) {\r\n            executorService.submit(new Thread(){\r\n                @Override\r\n                public void run() {\r\n                    try {\r\n                        lock.lock();\r\n                        conditionA.await(2000,TimeUnit.MILLISECONDS);\r\n                        System.out.println(Thread.currentThread().getName()+\" got the lock again\");\r\n                    } catch (InterruptedException e) {\r\n                        e.printStackTrace();\r\n                    }finally {\r\n                        lock.unlock();\r\n                    }\r\n                }\r\n            });\r\n        }\r\n\r\n        //conditionB\r\n        for (int i = 0; i < 3; i++) {\r\n            executorService.submit(new Thread(){\r\n                @Override\r\n                public void run() {\r\n                    lock.lock();\r\n                    try {\r\n                        conditionB.await(2000, TimeUnit.MILLISECONDS);\r\n                        System.out.println(Thread.currentThread().getName()+\" got the lock again\");\r\n                    } catch (InterruptedException e) {\r\n                        e.printStackTrace();\r\n                    }finally {\r\n                        lock.unlock();\r\n                    }\r\n                }\r\n            });\r\n        }\r\n\r\n        executorService.submit(new Thread(){\r\n            @Override\r\n            public void run() {\r\n                try {\r\n                    Thread.sleep(1000);\r\n                    lock.lock();\r\n                    conditionA.signalAll();\r\n                    System.out.println(Thread.currentThread().getName()+\" signalAll conditionA threads\");\r\n                } catch (InterruptedException e) {\r\n                    e.printStackTrace();\r\n                }finally {\r\n                    lock.unlock();\r\n                }\r\n            }\r\n        });\r\n\r\n        executorService.shutdown();\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n        singleConditionForThreads();\r\n        multipleConditionForThreadGroups();\r\n    }\r\n}\r\n```\r\n\r\n第二个示例的输出（注意时间间隔）\r\n```java\r\n//output\r\npool-1-thread-7 signalAll conditionA threads\r\npool-1-thread-1 got the lock again\r\npool-1-thread-2 got the lock again\r\npool-1-thread-3 got the lock again\r\npool-1-thread-4 got the lock again\r\npool-1-thread-5 got the lock again\r\npool-1-thread-6 got the lock again\r\n```\r\n### Semaphore\r\nSemaphore提供了信号量机制，作为mutex（互斥量）与ReentrantLock类似，不同的是，ReentrantLock中的Condition要求线程必须持有锁，并且一个锁只能被一个线程持有，而Semaphore允许多线程访问同一资源。当Semaphore不允许访问资源时，线程会被阻塞直到可以获取permit\r\n\r\n### API\r\n方法 | 解释\r\n---|---\r\nSemaphore(int permits, boolean fair) | 构造方法，两个参数分别表示permit数量，是否公平锁，默认非公平锁\r\nacquire()|获取permit，否则阻塞直到可以获取\r\nrelease()|释放permit，注意这里可以超过构造方法中允许的permit数量，也就是可以不用acquire直接release\r\navailablePermits()|查看目前可用的permit\r\ndrainPermits()|把permit置0，返回所有permit的数量\r\n\r\n#### 与其他锁机制的对比\r\nSemaphore不关心获取锁和释放锁的对象，并且允许多线程同时访问同一资源，acquire和release只是发放和收回permit（许可），是一种相对高级的同步机制\r\n\r\n#### Semaphore Example\r\n因为是高级API，所以没啥特别的，示例中一个容量为5的信号量跑20个线程，可以防止死锁，互斥执行\r\n```java\r\npublic class SemaphoreAPI {\r\n    public static void main(String[] args) {\r\n        Semaphore semaphore = new Semaphore(5);\r\n        ExecutorService executorService = Executors.newFixedThreadPool(20);\r\n        for (int i = 0; i < 20; i++) {\r\n            executorService.submit(()->{\r\n                try {\r\n                    semaphore.acquire();\r\n                    System.out.println(Thread.currentThread().getName()+\" is doing some work\");\r\n                    Thread.sleep(1000);\r\n                } catch (InterruptedException e) {\r\n                    e.printStackTrace();\r\n                }finally {\r\n                    semaphore.release();\r\n                }\r\n            });\r\n        }\r\n        executorService.shutdown();\r\n    }\r\n}\r\n```\r\n\r\n### refs\r\nhttps://juejin.im/post/5ce91cedf265da1bca51b78a\r\nhttps://stackoverflow.com/questions/17683575/binary-semaphore-vs-a-reentrantlock\r\nhttps://www.geeksforgeeks.org/reentrant-lock-java/","frontmatter":{"draft":null,"title":"","tags":null,"cover":null,"date":null}}},{"node":{"fields":{"slug":"/02-03-2017/random-project-4-with-super-long-title-phase-one","date":"2002-03-20T05:00:00.000Z"},"excerpt":"Artificem honorati ore temperat Lycus quam antiquumMendaci pinu ipsi nuncLorem markdownum supplex. Care ferre nos praemia detestatur oderit…","timeToRead":2,"rawMarkdownBody":"# Artificem honorati ore temperat Lycus quam antiquum\r\n\r\n## Mendaci pinu ipsi nunc\r\n\r\nLorem markdownum supplex. Care ferre nos praemia detestatur oderit vitatumque,\r\ntardius pello ostentare; dixit. [Agit](http://accessit.net/) super, cum, qua\r\nquae pinxit certamine occulte causa: est est non. Dubita fictumque imagine.\r\n\r\nIlli quid patitur limitibus sumptam in vincemur ducit tumulatus et odisse\r\nvolucris et cupit inrorant vivax, Proetus ait. Nec induit mortalia olim ortus\r\nfoedera [praecipitem](http://www.pontumferae.io/protinuset.html) amans et iter\r\n[est](http://casuquefuit.io/murmurevestrum.aspx) huc virginitate spernimus\r\nOenopiis longi ore paretur? Sede ore quaedam dumque. Et alti: Tagus vino omnes\r\nait dictis **videt vos**, meus licet bipennem, Acheronte! Fulvae vulneris et\r\nmunus succurritis coma simulacraque amborum semper, insequar quae **simul\r\ntela**.\r\n\r\n## Facta huic laboras matris tandem scelus\r\n\r\nPer praesuta occupat stratum, manuque te femina magni Nelidae. [Cauda\r\nlacrimisque](http://www.in.io/) sua nec quoque *prodiga*: more te aera est fas\r\nut utrumque omnes, fugae sua Telamone. Scilicet indulgere *dat terunt quam*\r\ncorpora, ad non Canentem gressu feliciter lapillis caede frequentes tibi nostro?\r\nAgmine in Phlegon illo oblita, ait quis negare orbem, prosunt tamen, praesentit\r\niussae Babylonius finita!\r\n\r\nInvictumque marmoreis simulatas solverat saevique nondum depositoque **ramisque\r\ninclusa**, dissiluit hoc malis, *simulacra*? Cum cupido alis. Ulmi redit\r\nadpellatque tellus, soror robore sequerere cuspidis quae putares! Mihi solidas\r\nsed tyranni tecta pennas virgine, unus aufer, *Oete* neve femina, vos quid.\r\nOscula dignior.\r\n\r\n## Corpore motae iam\r\n\r\nEst humum data tardus et movet attrahit ferro\r\n[imperio](http://soleta.org/lectos). Iam undis veniente et crines faciat\r\nMelaneus sedebat et vobis. Protinus obstantes Iunoni uni date lumen Appenninus\r\npanda electae Daedalion.\r\n\r\n> Adest clipeo perdere plena bellatricemque neque ut ponat vestigatque tinxi\r\n> gregibus petit labore super fidem barbare. Grates modo, ite lanugine procubuit\r\n> artes velatos, sensit fida mihi: negabo.\r\n> [Tum](http://www.mea-pars.net/temptanti) desubito radere tendens **fuit**.\r\n\r\nQuibus **se intus montibus**. Auro terrae: mare e adulterium, per dolet et.","frontmatter":{"draft":1,"title":"Random project 4 With Super Long Title Phase One","tags":["say hi"],"cover":"https://unsplash.it/1152/300/?random?SuperLong","date":"02/03/2017"}}},{"node":{"fields":{"slug":"Big-Sample_Test","date":"2001-03-20T05:00:00.000Z"},"excerpt":"NOTE: This \"post\" is based on Markdown Cheatsheet and is meant to test styling of Markdown generated documents.This is intended as a quick…","timeToRead":8,"rawMarkdownBody":"\r\n# NOTE: This \"post\" is based on [Markdown Cheatsheet](https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet) and is meant to test styling of Markdown generated documents.\r\n\r\n\r\nThis is intended as a quick reference and showcase. For more complete info, see [John Gruber's original spec](http://daringfireball.net/projects/markdown/) and the [Github-flavored Markdown info page](http://github.github.com/github-flavored-markdown/).\r\n\r\nThis cheatsheet is specifically *Markdown Here's* version of Github-flavored Markdown. This differs slightly in styling and syntax from what Github uses, so what you see below might vary a little from what you get in a *Markdown Here* email, but it should be pretty close.\r\n\r\nYou can play around with Markdown on our [live demo page](http://www.markdown-here.com/livedemo.html).\r\n\r\n(If you're not a Markdown Here user, check out the [Markdown Cheatsheet](./Markdown-Cheatsheet) that is not specific to MDH. But, really, you should also use Markdown Here, because it's awesome. http://markdown-here.com)\r\n\r\n##### Table of Contents\r\n\r\n[Headers](#headers)\r\n[Emphasis](#emphasis)\r\n[Lists](#lists)\r\n[Links](#links)\r\n[Images](#images)\r\n[Code and Syntax Highlighting](#code)\r\n[Tables](#tables)\r\n[Blockquotes](#blockquotes)\r\n[Inline HTML](#html)\r\n[Horizontal Rule](#hr)\r\n[Line Breaks](#lines)\r\n[YouTube Videos](#videos)\r\n\r\n<a name=\"headers\"/>\r\n\r\n## Headers\r\n\r\n```no-highlight\r\n# H1\r\n## H2\r\n### H3\r\n#### H4\r\n##### H5\r\n###### H6\r\n\r\nAlternatively, for H1 and H2, an underline-ish style:\r\n\r\nAlt-H1\r\n======\r\n\r\nAlt-H2\r\n------\r\n```\r\n\r\n# H1\r\n## H2\r\n### H3\r\n#### H4\r\n##### H5\r\n###### H6\r\n\r\nAlternatively, for H1 and H2, an underline-ish style:\r\n\r\nAlt-H1\r\n======\r\n\r\nAlt-H2\r\n------\r\n\r\n<a name=\"emphasis\"/>\r\n\r\n## Emphasis\r\n\r\n```no-highlight\r\nEmphasis, aka italics, with *asterisks* or _underscores_.\r\n\r\nStrong emphasis, aka bold, with **asterisks** or __underscores__.\r\n\r\nCombined emphasis with **asterisks and _underscores_**.\r\n\r\nStrikethrough uses two tildes. ~~Scratch this.~~\r\n```\r\n\r\nEmphasis, aka italics, with *asterisks* or _underscores_.\r\n\r\nStrong emphasis, aka bold, with **asterisks** or __underscores__.\r\n\r\nCombined emphasis with **asterisks and _underscores_**.\r\n\r\nStrikethrough uses two tildes. ~~Scratch this.~~\r\n\r\n\r\n<a name=\"lists\"/>\r\n\r\n## Lists\r\n\r\n```no-highlight\r\n1. First ordered list item\r\n2. Another item\r\n  * Unordered sub-list.\r\n1. Actual numbers don't matter, just that it's a number\r\n  1. Ordered sub-list\r\n4. And another item.\r\n\r\n   Some text that should be aligned with the above item.\r\n\r\n* Unordered list can use asterisks\r\n- Or minuses\r\n+ Or pluses\r\n```\r\n\r\n1. First ordered list item\r\n2. Another item\r\n\r\n   * Unordered sub-list.\r\n\r\n1. Actual numbers don't matter, just that it's a number\r\n\r\n   1. Ordered sub-list\r\n\r\n4. And another item.\r\n\r\n   Some text that should be aligned with the above item.\r\n\r\n* Unordered list can use asterisks\r\n- Or minuses\r\n+ Or pluses\r\n\r\n<a name=\"links\"/>\r\n\r\n## Links\r\n\r\nThere are two ways to create links.\r\n\r\n```no-highlight\r\n[I'm an inline-style link](https://www.google.com)\r\n\r\n[I'm a reference-style link][Arbitrary case-insensitive reference text]\r\n\r\n[You can use numbers for reference-style link definitions][1]\r\n\r\nOr leave it empty and use the [link text itself]\r\n\r\nURLs and URLs in angle brackets will automatically get turned into links.\r\nhttp://www.example.com or <http://www.example.com> and sometimes\r\nexample.com (but not on Github, for example).\r\n\r\nSome text to show that the reference links can follow later.\r\n\r\n[arbitrary case-insensitive reference text]: https://www.mozilla.org\r\n[1]: http://slashdot.org\r\n[link text itself]: http://www.reddit.com\r\n```\r\n\r\n[I'm an inline-style link](https://www.google.com)\r\n\r\n[I'm a reference-style link][Arbitrary case-insensitive reference text]\r\n\r\n[You can use numbers for reference-style link definitions][1]\r\n\r\nOr leave it empty and use the [link text itself]\r\n\r\nURLs and URLs in angle brackets will automatically get turned into links.\r\nhttp://www.example.com or <http://www.example.com> and sometimes\r\nexample.com (but not on Github, for example).\r\n\r\nSome text to show that the reference links can follow later.\r\n\r\n[arbitrary case-insensitive reference text]: https://www.mozilla.org\r\n[1]: http://slashdot.org\r\n[link text itself]: http://www.reddit.com\r\n\r\n<a name=\"images\"/>\r\n\r\n## Images\r\n\r\n```no-highlight\r\nHere's our logo (hover to see the title text):\r\n\r\nInline-style:\r\n![alt text](https://github.com/adam-p/markdown-here/raw/master/src/common/images/icon48.png \"Logo Title Text 1\")\r\n\r\nReference-style:\r\n![alt text][logo]\r\n\r\n[logo]: https://github.com/adam-p/markdown-here/raw/master/src/common/images/icon48.png \"Logo Title Text 2\"\r\n```\r\n\r\nHere's our logo (hover to see the title text):\r\n\r\nInline-style:\r\n![alt text](https://github.com/adam-p/markdown-here/raw/master/src/common/images/icon48.png \"Logo Title Text 1\")\r\n\r\nReference-style:\r\n![alt text][logo]\r\n\r\n[logo]: https://github.com/adam-p/markdown-here/raw/master/src/common/images/icon48.png \"Logo Title Text 2\"\r\n\r\n<a name=\"code\"/>\r\n\r\n## Code and Syntax Highlighting\r\n\r\nCode blocks are part of the Markdown spec, but syntax highlighting isn't. However, many renderers -- like Github's and *Markdown Here* -- support syntax highlighting. *Markdown Here* supports highlighting for dozens of languages (and not-really-languages, like diffs and HTTP headers); to see the complete list, and how to write the language names, see the [highlight.js demo page](http://softwaremaniacs.org/media/soft/highlight/test.html).\r\n\r\n```no-highlight\r\nInline `code` has `back-ticks around` it.\r\n```\r\n\r\nInline `code` has `back-ticks around` it.\r\n\r\nBlocks of code are either fenced by lines with three back-ticks <code>```</code>, or are indented with four spaces. I recommend only using the fenced code blocks -- they're easier and only they support syntax highlighting.\r\n\r\n<pre lang=\"no-highlight\"><code>```javascript\r\nvar s = \"JavaScript syntax highlighting\";\r\nalert(s);\r\n```\r\n\r\n```python\r\ns = \"Python syntax highlighting\"\r\nprint s\r\n```\r\n\r\n```\r\nNo language indicated, so no syntax highlighting.\r\nBut let's throw in a &lt;b&gt;tag&lt;/b&gt;.\r\n```\r\n</code></pre>\r\n\r\n\r\n\r\n```javascript\r\nvar s = \"JavaScript syntax highlighting\";\r\nalert(s);\r\n```\r\n\r\n```python\r\ns = \"Python syntax highlighting\"\r\nprint s\r\n```\r\n\r\n```\r\nNo language indicated, so no syntax highlighting in Markdown Here (varies on Github).\r\nBut let's throw in a <b>tag</b>.\r\n```\r\n\r\nAgain, to see what languages are available for highlighting, and how to write those language names, see the [highlight.js demo page](http://softwaremaniacs.org/media/soft/highlight/test.html).\r\n\r\n<a name=\"tables\"/>\r\n\r\n## Tables\r\n\r\nTables aren't part of the core Markdown spec, but they are part of GFM and *Markdown Here* supports them. They are an easy way of adding tables to your email -- a task that would otherwise require copy-pasting from another application.\r\n\r\n```no-highlight\r\nColons can be used to align columns.\r\n\r\n| Tables        | Are           | Cool  |\r\n| ------------- |:-------------:| -----:|\r\n| col 3 is      | right-aligned | $1600 |\r\n| col 2 is      | centered      |   $12 |\r\n| zebra stripes | are neat      |    $1 |\r\n\r\nThe outer pipes (|) are optional, and you don't need to make the raw Markdown line up prettily. You can also use inline Markdown.\r\n\r\nMarkdown | Less | Pretty\r\n--- | --- | ---\r\n*Still* | `renders` | **nicely**\r\n1 | 2 | 3\r\n```\r\n\r\nColons can be used to align columns.\r\n\r\n| Tables        | Are           | Cool |\r\n| ------------- |:-------------:| -----:|\r\n| col 3 is      | right-aligned | $1600 |\r\n| col 2 is      | centered      |   $12 |\r\n| zebra stripes | are neat      |    $1 |\r\n\r\nThe outer pipes (|) are optional, and you don't need to make the raw Markdown line up prettily. You can also use inline Markdown.\r\n\r\nMarkdown | Less | Pretty\r\n--- | --- | ---\r\n*Still* | `renders` | **nicely**\r\n1 | 2 | 3\r\n\r\n<a name=\"blockquotes\"/>\r\n\r\n## Blockquotes\r\n\r\n```no-highlight\r\n> Blockquotes are very handy in email to emulate reply text.\r\n> This line is part of the same quote.\r\n\r\nQuote break.\r\n\r\n> This is a very long line that will still be quoted properly when it wraps. Oh boy let's keep writing to make sure this is long enough to actually wrap for everyone. Oh, you can *put* **Markdown** into a blockquote.\r\n```\r\n\r\n> Blockquotes are very handy in email to emulate reply text.\r\n> This line is part of the same quote.\r\n\r\nQuote break.\r\n\r\n> This is a very long line that will still be quoted properly when it wraps. Oh boy let's keep writing to make sure this is long enough to actually wrap for everyone. Oh, you can *put* **Markdown** into a blockquote.\r\n\r\n<a name=\"html\"/>\r\n\r\n## Inline HTML\r\n\r\nYou can also use raw HTML in your Markdown, and it'll mostly work pretty well.\r\n\r\n```no-highlight\r\n<dl>\r\n  <dt>Definition list</dt>\r\n  <dd>Is something people use sometimes.</dd>\r\n\r\n  <dt>Markdown in HTML</dt>\r\n  <dd>Does *not* work **very** well. Use HTML <em>tags</em>.</dd>\r\n</dl>\r\n```\r\n\r\n<dl>\r\n  <dt>Definition list</dt>\r\n  <dd>Is something people use sometimes.</dd>\r\n\r\n  <dt>Markdown in HTML</dt>\r\n  <dd>Does *not* work **very** well. Use HTML <em>tags</em>.</dd>\r\n</dl>\r\n\r\n<a name=\"hr\"/>\r\n\r\n## Horizontal Rule\r\n\r\n```\r\nThree or more...\r\n\r\n---\r\n\r\nHyphens\r\n\r\n***\r\n\r\nAsterisks\r\n\r\n___\r\n\r\nUnderscores\r\n```\r\n\r\nThree or more...\r\n\r\n---\r\n\r\nHyphens\r\n\r\n***\r\n\r\nAsterisks\r\n\r\n___\r\n\r\nUnderscores\r\n\r\n<a name=\"lines\"/>\r\n\r\n## Line Breaks\r\n\r\nMy basic recommendation for learning how line breaks work is to experiment and discover -- hit &lt;Enter&gt; once (i.e., insert one newline), then hit it twice (i.e., insert two newlines), see what happens. You'll soon learn to get what you want. \"Markdown Toggle\" is your friend.\r\n\r\nHere are some things to try out:\r\n\r\n```\r\nHere's a line for us to start with.\r\n\r\nThis line is separated from the one above by two newlines, so it will be a *separate paragraph*.\r\n\r\nThis line is also a separate paragraph, but...\r\nThis line is only separated by a single newline, so it's a separate line in the *same paragraph*.\r\n```\r\n\r\nHere's a line for us to start with.\r\n\r\nThis line is separated from the one above by two newlines, so it will be a *separate paragraph*.\r\n\r\nThis line is also begins a separate paragraph, but...\r\nThis line is only separated by a single newline, so it's a separate line in the *same paragraph*.\r\n\r\n(Technical note: *Markdown Here* uses GFM line breaks, so there's no need to use MD's two-space line breaks.)\r\n\r\n<a name=\"videos\"/>\r\n\r\n## YouTube Videos\r\n\r\nThey can't be added directly but you can add an image with a link to the video like this:\r\n\r\n```no-highlight\r\n<a href=\"http://www.youtube.com/watch?feature=player_embedded&v=8AkLfYOgIrE\r\n\" target=\"_blank\"><img src=\"http://img.youtube.com/vi/8AkLfYOgIrE/0.jpg\"\r\nalt=\"IMAGE ALT TEXT HERE\" width=\"240\" height=\"180\" border=\"10\" /></a>\r\n```\r\n\r\nOr, in pure Markdown, but losing the image sizing and border:\r\n\r\n```no-highlight\r\n[![IMAGE ALT TEXT HERE](http://img.youtube.com/vi/YOUTUBE_VIDEO_ID_HERE/0.jpg)](http://www.youtube.com/watch?v=YOUTUBE_VIDEO_ID_HERE)\r\n```\r\n","frontmatter":{"draft":1,"title":"Big Test","tags":["test","huge"],"cover":"https://unsplash.it/400/300/?random?BigTest","date":"01/03/2018"}}}]}},"pageContext":{"isCreatedByStatefulCreatePages":true}}