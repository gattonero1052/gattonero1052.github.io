{"componentChunkName":"component---src-templates-tag-jsx","path":"/tags/dfa/","result":{"data":{"allMarkdownRemark":{"totalCount":1,"edges":[{"node":{"fields":{"slug":"/algorithm/regular-expression-for-multiple-of-3","date":"2019-10-22T04:00:00.000Z"},"excerpt":"问题 使用正则判断n能否被3整除 思路 根据整除性构建DFA（确定有限自动状态机），再根据DFA构建正则（Kleen算法） 解决 我们从高位读取字符串，并将余数作为状态，有如下状态转移表：\nX |'0''1'\n0 | 0  1\n1 | 2  0\n2 | 1  2\n（X…","timeToRead":1,"rawMarkdownBody":"\r\n### 问题\r\n使用正则判断n能否被3整除\r\n### 思路\r\n根据整除性构建DFA（确定有限自动状态机），再根据DFA构建正则（[Kleen算法](https://en.wikipedia.org/wiki/Kleene%27s_algorithm)）\r\n### 解决\r\n我们从高位读取字符串，并将余数作为状态，有如下状态转移表：\r\nX |'0''1'\r\n0 | 0  1\r\n1 | 2  0\r\n2 | 1  2\r\n（X表示 状态\\当前字符）\r\n比如说状态是2，说明当前数字除3余2，那么当前字符是'0'时，余数自然是1，应该转移到1状态\r\n\r\nDFA如下：\r\n![DFA](https://upload-images.jianshu.io/upload_images/4655525-0c49a4eac221f80f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\r\n\r\n初始状态是0，我们只要判断终结状态是否为0即可\r\n观察图中的一个自环和一个0-1-2-1-0的大环，我们可以写出两种正则\r\n`0*`\r\n`1(01*0)*1`\r\n故得到  `(0 | 1(01*0)*1)*`\r\n\r\n### 代码\r\n```javascript\r\nfor(var i=1;i<100;i++)\r\n if(!/^(0|1(01*0)*1)*$/.test(Number(3*i).toString(2))) console.log(i)//undefined\r\n```\r\n\r\n### Tips\r\n- 符合要求的正则不止一个，但是上述正则应该是最简单的之一\r\n- 按照相应算法，可以获得任意数字的整除性判断正则\r\n\r\n### Ref\r\n>https://en.wikipedia.org/wiki/Kleene%27s_algorithm\r\n>https://zhidao.baidu.com/question/1383837207982172220.html\r\n>Algorithm 4th P518","frontmatter":{"abstract":"使用正则判断n能否被3整除","draft":null,"title":"Regular Expression For Multiple of 3","tags":["中文","algorithm","regular-expression","DFA"],"cover":"","date":"2019/10/22"}}}]}},"pageContext":{"tag":"DFA"}},"staticQueryHashes":[]}