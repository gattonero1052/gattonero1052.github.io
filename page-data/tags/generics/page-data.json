{"componentChunkName":"component---src-templates-tag-jsx","path":"/tags/generics/","result":{"data":{"allMarkdownRemark":{"totalCount":1,"edges":[{"node":{"fields":{"slug":"/Java/java-generics-tricky-code","date":"2019-10-25T04:00:00.000Z"},"excerpt":"Purpose 收集整理一些比较难以理解的Java泛型问题，以及详细解释其中的原理 List Wildcards PECS (Producer extend, Consumer super) Class and Interface Producer 其中表示的是Father…","timeToRead":14,"rawMarkdownBody":"### Purpose\r\n收集整理一些比较难以理解的Java泛型问题，以及详细解释其中的原理\r\n\r\n---\r\n### List Wildcards\r\nPECS (Producer extend, Consumer super)\r\n#### Class and Interface\r\n```java\r\ninterface Grandpa {}\r\ninterface Grandma {}\r\ninterface Father extends Grandpa,Grandma {}\r\ninterface Son extends Father {}\r\ninterface Daughter extends Father {}\r\n\r\nclass CGrandpa implements Grandpa {}\r\nclass CGrandma implements Grandma {}\r\n...\r\n```\r\n#### Producer\r\n```java\r\nList<? extends Father> producer = new ArrayList();\r\n```\r\n\r\n其中`? extends Father`表示的是Father的subtype，包括Father\r\n```java\r\nList<? extends Father> son_producer = new ArrayList<Son>();\r\nList<? extends Father> daughter_producer = new ArrayList<Daughter>();\r\nList<? extends Father> father_producer = new ArrayList<Father>();\r\n//all above are valid, below are invalid\r\nList<? extends Father> producer = new ArrayList<Grandpa>();\r\nList<? extends Father> producer = new ArrayList<Grandma>();\r\n```\r\n对于函数参数为该泛型的方法，例如`boolean add(E e)`\r\n```java\r\nson_producer.add(new CSon()); // invalid\r\nson_producer.add(new CFather()); // invalid\r\nson_producer.add(new CGrandpa()); // invalid\r\nson_producer.add(null); //valid\r\n```\r\n不能使用任何非空元素作为参数的原因是：\r\n- add的函数声明`boolean add(E e)`中，函数参数为 `E`，和List中的泛型相同\r\n- `? extends Father`代表任何Father或Father的subtype，所以该泛型的subtype是不确定的，但是supertype确定\r\n\r\n- 从而除了null以外，任何参数的类型都无法保证可以作为该泛型的子类从而进行upcasting，所以只能使用null作为函数的参数\r\n\r\n对于返回类型为该泛型的方法，例如`E get(int index)`\r\n```java\r\nList<Son> sonList = new ArrayList<>();\r\nsonList.add( new CSon() );\r\nsonList.add( new CSon() );\r\nsonList.add( new CSon() );\r\nson_producer = sonList;\r\n\r\nFather father = son_producer.get(0);//valid\r\nGrandpa grandpa = son_producer.get(0);//valid\r\n```\r\n因为返回值是Father的subtype，所以可以进行upcasting，获取所需的supertype对象\r\n#### Consumer\r\n```java\r\nList<? super Father> consumer = new ArrayList();\r\n```\r\n其中`<? super Father>`表示Father的supertype，包括Father\r\n```java\r\nList<? super Father> grandpa_consumer = new ArrayList<Grandpa>();\r\nList<? super Father> grandma_consumer = new ArrayList<Grandma>();\r\nList<? super Father> father_consumer = new ArrayList<Father>();\r\n//all above are valid, below are invalid\r\nList<? super Father> son_consumer = new ArrayList<Son>();\r\nList<? super Father> daughter_consumer = new ArrayList<Daughter>();\r\n```\r\n对于函数参数为该泛型的方法，例如`boolean add(E e)`\r\n```java\r\nfather_consumer.add(new CFather());//valid\r\nfather_consumer.add(new CSon());//valid\r\nfather_consumer.add(null);//valid\r\nfather_consumer.add(new CGrandpa());//invalid\r\n```\r\n可以使用任何Father以及其subtype的原因是：\r\n- add的函数声明`boolean add(E e)`中，函数参数为 `E`，和List中的泛型相同\r\n- `? super Father`代表Father或Father的supertype，所以该泛型的subtype确定，而supertype可以看成统一为Object\r\n- 从而任何Father的subtype都可以作为参数，upcasting为该泛型，当然null也可以\r\n对于返回类型为该泛型的方法，例如`E get(int index)`\r\n```java\r\nFather father = father_consumer.get(0);//invalid\r\nObject object = father_consumer.get(0);//valid\r\n```\r\n这里要把泛型的supertype不确定，所以在没有强制转换的情况下，只能返回对象只能是Object类型的\r\n\r\n#### Tips\r\n- `<? extends XXX>`和`<? super XXX>`这两个通配符的行为并不对称，原因在于子类的upcasting可以是隐式的，而父类的downcasting并不是\r\n- 假设类泛型为E，当E作为方法参数时，我们需要把某个类upcasting成E，而E作为方法返回值时，我们需要把E upcasting成某个类\r\n- 因为通过接口实现的多态也符合泛型的规则，所以这里不使用子类(subclass)和父类(superclass)的称呼，而使用subtype和supertype\r\n- Object是任何类的supertype，没有哪个类是任何类的subtype\r\n- null是任何类的对象\r\n\r\n--- \r\n### Wildcard Capture\r\n通配符捕获\r\n### Code\r\n\r\n```java\r\nvoid foo(List<?> i) {\r\n    i.set(0, i.get(0));//invalid\r\n}\r\n\r\nvoid foo(List i) {\r\n    i.set(0, i.get(0));//valid\r\n}\r\n\r\n<T> void foo(List<T> i) {\r\n    i.set(0, i.get(0));//valid\r\n}\r\n```\r\n\r\n错误原因\r\n- ? 作为通配符，表示任意一个类（? 可以理解为 ? extends Object），通常被编译器用作类型推断使用，但是当编译器无法做出类型推断，从而无法保证类型安全时，就会抛出包含\"capture of\"的错误\r\n- `i.get(0)`没有问题，可以获取其中的元素`Object o = i.get( 0 );//valid`\r\n- set方法的声明是`E set(int index, E element)`，也就是说，List的泛型必须和入参保持一致\r\n- ? 代表了任意类，而显然Object类型无法进行upcasting\r\n\r\n而对于其余两种方法，编译器可以确定`i.get(0)`的类型是i.set所需的类型（保证可以upcasting），换句话说，下面代码断的报错方式，和第一个是同一个原理\r\n```java\r\n<T> void foo(List<T> i) {\r\n    i.set(0, (Object)i.get(0));//invalid\r\n}\r\n```\r\n---\r\n### Erasure and override\r\n类型擦除与方法覆写\r\n#### Code\r\n```java\r\npublic class Node<T> {\r\n\r\n    public T data;\r\n\r\n    public Node(T data) { this.data = data; }\r\n\r\n    public void setData(T data) {\r\n        System.out.println(\"Node.setData\");\r\n        this.data = data;\r\n    }\r\n}\r\n\r\npublic class MyNode extends Node<Integer> {\r\n    public MyNode(Integer data) { super(data); }\r\n\r\n    public void setData(Integer data) {\r\n        System.out.println(\"MyNode.setData\");\r\n        super.setData(data);\r\n    }\r\n}\r\n```\r\n问题是，下列代码是怎么输出的：\r\n```java\r\nMyNode mn = new MyNode(5);\r\nNode n = mn;\r\nn.setData(\"Hello\");     \r\nInteger x = mn.data;\r\n```\r\n我们假设类型擦除能够正常运作，那么Node类中的函数签名中的泛型，都会被改成Object类型，也就是类似Node(Object data)\r\n\r\n那么MyNode中的setData，就不会override Node中的setData，因为签名不同，所以`n.setData(\"Hello\")`会正常执行，错误会在`Integer x = mn.data`这里\r\n\r\n但实际情况并不是这样，ClassCastException会在`n.setData(\"Hello\")`被执行时抛出，而不是下一句\r\n\r\n原因在于，这里起到作用的是Bridge Method。\r\n\r\n对于多态（polymorphism）的实现来说，子类如果继承泛型类的方法，那么也应该override其方法，而不应该因为类型擦除而保留一个并未定义过的签名中包含Object的原始方法\r\n\r\n这里的setData(Object data)应该被setData(Integer data) override，这样才符合多态。为了满足这点，编译器就会针对泛型类的子类生成Bridge Method\r\n\r\n```java\r\n// Bridge method generated by the compiler\r\n//\r\npublic void setData(Object data) {\r\n    setData((Integer) data);\r\n}\r\n```\r\n\r\n试想如果有了这个自动生成的方法，是不是就可以解释为什么ClassCastException会在`n.setData(\"Hello\");`中被抛出，而String类作为`n.setData`的参数，并不会产生错误\r\n\r\n总结一下，继承泛型类之后，**不用考虑类型擦除后生成的新方法会不会被override这样的问题**，因为有Bridge method，类型擦除后，生成的参数类型为Object的方法实际上会被override并转到新方法中\r\n\r\n#### Tips\r\n- Bridge Method可以被反射获取到，也可以通过反射调用，通过`method.isBridge()`可以获取一个方法是否是Bridge Mehtod\r\n- 方法泛型的目的是为了保证编译期的类型安全，并不会给运行时添加负担，也就是说，加不加泛型对于运行时影响不大（加了泛型后可能少了类型强转的字节码，其他字节码不会发生变化）\r\n- 两个字节码完全一致但使用方式不同的函数：\r\n\r\n```java\r\n<T> T foo(List<T> i) {\r\n    i.set(0, i.get(0));\r\n    return i.get( 0 );\r\n}\r\n\r\nObject foo2(List i) {\r\n    i.set(0, i.get(0));\r\n    return i.get( 0 );\r\n}\r\n```\r\n\r\n基于Java的类型擦除机制，这两个函数在运行期的字节码是完全相同的，但是\r\n```java\r\nObject o = foo(new ArrayList<String>(Arrays.asList(\"1\",\"2\")));//valid\r\nString s = foo(new ArrayList<String>(Arrays.asList(\"1\",\"2\")));//valid\r\n\r\nObject o2 = foo2(new ArrayList<String>(Arrays.asList(\"1\",\"2\")));//valid\r\nString s2 = foo2(new ArrayList<String>(Arrays.asList(\"1\",\"2\")));//invalid\r\n```\r\n最后一行会出现编译期错误，因为不符合类型安全的要求\r\n- 上面例子中`Arrays.asList(\"1\",\"2\")`的返回值是`java.util.Arrays.ArrayList`，不是`java.util.ArrayList`，要加一层构造方法包装\r\n\r\n---\r\n### Recursive Generics\r\n递归泛型\r\n#### Code\r\n```java\r\npublic abstract class Node <N extends Node<N>>  {\r\n    public final List<N> children = new ArrayList<N>();\r\n    public final N parent;\r\n\r\n    protected Node(N parent) {\r\n        this.parent = parent;\r\n        parent.children.add(this);  // error: incompatible types\r\n    }\r\n\r\n    public N getParent() {\r\n        return parent;\r\n    }\r\n    public List<N> getChildren() {\r\n        return children;\r\n    }\r\n}\r\n\r\npublic class SpecialNode extends Node<SpecialNode> {\r\n    public SpecialNode(SpecialNode parent) {\r\n        super(parent);\r\n    }\r\n}\r\n```\r\n我们的问题是，为什么会出现error\r\n\r\n首先，定义这个两个class的目的在于：定义一种类的抽象行为，即在初始化的时候把一个自身成员加进一个ArrayList的实例变量中\r\n\r\n其中，通过泛型确保加进的对象一定是子类（N extends Node<N>），这里看上去像是一种递归形式的定义从而无法处理，其实只需要考虑N extends Node就可以了，因为这是一种特殊的写法，举个例子\r\n\r\n```java\r\npublic static abstract class Node <N extends Node<N>>  {...}\r\n```\r\n是可行的，但是\r\n```java\r\npublic static abstract class Node <N extends Node<N extends<Node<N>>>>  {...}\r\n```\r\n是不可行的，尽管语义相同\r\n\r\n所以说这样递归定义的泛型，是一种特殊的表示，表示子类声明的泛型必须是子类自身\r\n\r\n如果这样还是难以理解，下面这个例子说明了`Node <N extends Node<N>>` 和 `Node <N extends Node>` 的区别\r\n\r\n对于递归泛型`<N extends Node<N>>`\r\n```java\r\nabstract class Node <N extends Node<N>>  {\r\n    ...\r\n}\r\n    \r\n//invalid\r\nclass SpecialNode extends Node<Node> {\r\n    ...\r\n}\r\n\r\n//valid\r\nclass SpecialNode extends Node<SpecialNode> {\r\n    ...\r\n}\r\n```\r\n而对于非递归泛型`<N extends Node>`\r\n```java\r\nabstract class Node <N extends Node>  {\r\n    ...\r\n}\r\n    \r\n//valid\r\nclass SpecialNode extends Node<Node> {\r\n    ...\r\n}\r\n\r\n//valid\r\nclass SpecialNode extends Node<SpecialNode> {\r\n    ...\r\n}\r\n```\r\n\r\n回到之前的问题\r\n```java\r\nparent.children.add(this);  // error: incompatible types\r\n```\r\n这里，ArrayList里存储的对象应该是N，而this所获取的并不是N，而是N的supertype，所以不能进行upcasting\r\n\r\n解决方法：\r\n- 进行类型强转`add((N)this)`\r\n- 改变ArrayList的泛型`public final List<? super Node> children = new ArrayList<>();`，并修改getChildren的返回值·`public List getChildren() {...`\r\n- 通过方法直接获取N的实例，即在抽象类中定义方法，在子类中实现\r\n\r\n```java\r\n\r\n//abstract class\r\nabstract N getThis();\r\n\r\n//subclass\r\nSpecialNode getThis(){ return this; }\r\n```\r\n\r\n---\r\n### Embedded Generic Infer\r\n泛型方法嵌套中的类型推断\r\n#### Code\r\n```java\r\nstatic <T> T[] topFn(T t1, T t2){\r\n    return subFn( t1, t2 );\r\n}\r\n\r\nstatic <T> T[] subFn(T...ts){\r\n    return ts;\r\n}\r\n\r\npublic static void main( String[] args ) {\r\n    subFn(\"Hello\",\"World\"); //valid\r\n    topFn( \"Hello\",\"World\" ); //valid\r\n\r\n    String[] results = subFn(\"Hello\",\"World\"); //valid\r\n    results = topFn( \"Hello\",\"World\" ); //invalid\r\n}\r\n```\r\n首先我们观察`subFn(\"Hello\",\"World\")`，通过类型推断，编译器把subFn中的参数替换为了String，从而返回`String[]`，这点没有问题\r\n\r\n再观察`topFn( \"Hello\",\"World\" );`，在编译器，同样地通过类型推断，我们知道该函数返回的也是`String[]`，但是对于函数内部的调用，我们无法通过类型推断去替换subFn的泛型T，从而subFn返回的是`Object[]`\r\n\r\n所以方法可以调用，但是返回值不是本来期望的，将`Object[]`强转成`String[]`会发生错误\r\n\r\n解决方法：把遍历`Object[]`强转所有元素到`String[]`即可，但这比较复杂，所以尽量避免泛型方法的嵌套\r\n#### Tips\r\n- 函数的类型推断仅仅作用在编译期，也就是说，如果一段代码必须通过执行能确定其类型，那么类型推断是无法作用的\r\n\r\n---\r\n### Java Version Matters\r\n\r\n#### Method\r\n```java\r\nstatic void handleList(List<String> list){}\r\n```\r\n#### Code\r\n```java\r\nList<String> stringList = Collections.emptyList();//valid\r\nhandleList(Collections.<String>emptyList())//valid\r\nhandleList(Collections.emptyList());//depend on Java version\r\n```\r\n在Java SE 7和Java SE 7之前，是无法从函数的参数类型进行类型推断的，必须显式指定，但Java SE8之后可以\r\n\r\n\r\n### Refs\r\n>https://stackoverflow.com/questions/1910892/what-is-the-difference-between-super-and-extends-in-java-generics\r\n\r\n>https://stackoverflow.com/questions/4343202/difference-between-super-t-and-extends-t-in-java\r\n\r\n>https://www.cnblogs.com/hongdada/p/10683795.html\r\n\r\n>https://stackoverflow.com/questions/5836662/extending-from-two-classes\r\n\r\n>https://docs.oracle.com/javase/tutorial/java/generics/\r\n\r\n>http://www.angelikalanger.com/GenericsFAQ/FAQSections/ProgrammingIdioms.html#FAQ205\r\n\r\n>https://jrebel.com/rebellabs/java-generics-cheat-sheet/","frontmatter":{"abstract":"收集整理一些比较难以理解的Java泛型问题，以及详细解释其中的原理","draft":null,"title":"Java Generics Tricky Code","tags":["中文","java","generics"],"cover":"","date":"2019/10/25"}}}]}},"pageContext":{"isCreatedByStatefulCreatePages":false,"tag":"generics"}}}