{"componentChunkName":"component---src-templates-tag-jsx","path":"/tags/graph/","result":{"data":{"allMarkdownRemark":{"totalCount":1,"edges":[{"node":{"fields":{"slug":"/algorithm/largest-component-size-by-common-factor","date":"2019-06-15T04:00:00.000Z"},"excerpt":"问题 无向图中，顶点是数字，两个数字的最大公因子大于1时有边，求连通分量 思路 不能直接dfs，考虑接近dfs的另一种算法，并查集\n当然，如果直接把数据放在并查集里，并不会降低时间复杂度（实质上依然是两两比较，O(log2(n)*n^…","timeToRead":3,"rawMarkdownBody":"### 问题\r\n无向图中，顶点是数字，两个数字的最大公因子大于1时有边，求连通分量\r\n\r\n\r\n### 思路\r\n不能直接dfs，考虑接近dfs的另一种算法，并查集\r\n当然，如果直接把数据放在并查集里，并不会降低时间复杂度（实质上依然是两两比较，O(log2(n)*n^2)）\r\n对于降低时间复杂度的办法，我们从题目的特性出发，如果两数之间有大于1的公因数，那么他们在同一个连通子图内\r\n\r\n也就是说，只要这个数有2这个因子，就直接往2的连通子图的union find根节点权值上加1就行了，完全不需要把这个数和其余的所有偶数一一比较，他们肯定在同一个连同子图下面\r\n\r\n换句话说，为了求连通分量的最大值，我们不需要画出整个图，只需要画出关键部位就行\r\n![需要这样吗](https://upload-images.jianshu.io/upload_images/4655525-6372a4641804b41c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\r\n![不需要](https://upload-images.jianshu.io/upload_images/4655525-bb2f27424448da68.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\r\n并查集的写法也注意一下，加权并查集在时间效率上会高很多\r\n\r\n```java\r\nimport java.util.*;\r\nimport java.util.stream.*;\r\nimport java.math.*;\r\n\r\npublic class Solution {\r\n\r\n    //并查集\r\n    int MAX=100000;\r\n\r\n    //用不加权并查集的话，把count去掉就行，代码简单一点\r\n    int[] count=new int[MAX],find = new int[MAX];\r\n\r\n    //这个是加权并查集的方法\r\n    public int count(int a){\r\n        return count[find(a)];\r\n    }\r\n\r\n    public int find(int a){\r\n        while(find[a]!=a)a=find[a];\r\n        return a;\r\n    }\r\n\r\n    public void union(int a,int b){\r\n        a=find(a);\r\n        b=find(b);\r\n\r\n        if(a==b)return;\r\n\r\n        if(count[a]>count[b]){\r\n            count[a]+=count[b];\r\n            find[b] = a;\r\n        }else{\r\n            count[b]+=count[a];\r\n            find[a] = b;\r\n        }\r\n    }\r\n\r\n    public int largestComponentSize(int[] A) {\r\n        //初始化并查集\r\n        for (int i = 0; i < MAX; i++) {\r\n            find[i] = i;\r\n            count[i] = 1;\r\n        }\r\n\r\n        Map<Integer,Integer> factorMap = new HashMap<>();\r\n\r\n        for (int i = 0; i < A.length; i++) {\r\n            double sqrt=Math.sqrt(A[i]);\r\n            for (int j = 2; j <=sqrt; j++) {\r\n                if(A[i] % j==0){\r\n                    unionMap(factorMap,j,i);\r\n                    unionMap(factorMap,A[i]/j,i);\r\n                }\r\n            }\r\n\r\n            unionMap(factorMap,A[i],i);\r\n        }\r\n\r\n        int max = 1;\r\n\r\n        for (int i = 0; i < A.length; i++) {\r\n            max = Math.max(max,count(i));\r\n        }\r\n\r\n        return max;\r\n    }\r\n\r\n    public void unionMap(Map<Integer,Integer> factorMap,int factor,int cur){\r\n        if(factorMap.containsKey(factor)){\r\n            union(factorMap.get(factor),cur);\r\n        }else{\r\n            factorMap.put(factor,cur);\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n### Tips\r\n- 这是Contest 113里的最后一题\r\n- 加权并查集在很多情况下其实本来就比并查集效率要高，这题不管从什么方面考虑，都应该使用加权并查集\r\n- 循环因数的时候可以顺便判断一下这个数是不是质数，不过没必要（if (isPrime) unionMap(factorMap,A[i],i);）","frontmatter":{"abstract":"无向图中，顶点是数字，两个数字的最大公因子大于1时有边，求连通分量","draft":null,"title":"Largest Component Size By Common Factor","tags":["中文","algorithm","graph"],"cover":"","date":"2019/6/15"}}}]}},"pageContext":{"isCreatedByStatefulCreatePages":false,"tag":"graph"}}}