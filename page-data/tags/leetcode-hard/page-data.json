{
    "componentChunkName": "component---src-templates-tag-jsx",
    "path": "/tags/leetcode-hard/",
    "result": {"data":{"allMdx":{"totalCount":4,"edges":[{"node":{"fields":{"slug":"/leetcode/leetcode-hard-page-2","date":"2022-02-04T05:00:00.000Z"},"excerpt":"Smallest Rectangle Enclosing Black Pixels Given a 2D n*m matrix with 0 and 1 representing white and black pixels. All black pixels are…","timeToRead":2,"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Leetcode Hard Page 2\",\n  \"cover\": \"\",\n  \"category\": \"Algorithm\",\n  \"date\": \"2022/02/04\",\n  \"abstract\": \"\",\n  \"tags\": [\"Leetcode\", \"Leetcode hard\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h3\", {\n    \"id\": \"smallest-rectangle-enclosing-black-pixels\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#smallest-rectangle-enclosing-black-pixels\",\n    \"aria-label\": \"smallest rectangle enclosing black pixels permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Smallest Rectangle Enclosing Black Pixels\"), mdx(\"p\", null, \"Given a 2D n*m matrix with 0 and 1 representing white and black pixels. All black pixels are connected.\\nFind the bouding rectangle of all black pixels in less than O(mn).\\nFor each row, do a binary search to find the maximum y of all black pixels, just think of all the black\\npixels are projected to a 1D line.\"), mdx(\"div\", {\n    \"className\": \"gatsby-highlight\",\n    \"data-language\": \"text\"\n  }, mdx(\"pre\", {\n    parentName: \"div\",\n    \"className\": \"language-text\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-text\"\n  }, \"0         0\\n0         0\\n0         0 <- Seach for the minimum Y\\n1         1\\n1         1                               \\nY         Y                                   Y\\n1              Seach for the maximum Y   ->   1\\n0                                             0\\n0                                             0\"))), mdx(\"p\", null, \"For x it's similar. Overall time complexity O(nlogm + mlogn)\"), mdx(\"h3\", {\n    \"id\": \"number-of-islands-ii\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#number-of-islands-ii\",\n    \"aria-label\": \"number of islands ii permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Number of Islands II\"), mdx(\"p\", null, \"Given a list of points in a 2D matrix, return an array of number of islands if these points are put into the matrix by order.\\nJust use union find to connect different points, each time two points of different islands are connected, add the result by 1.\"), mdx(\"h3\", {\n    \"id\": \"burst-ballons\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#burst-ballons\",\n    \"aria-label\": \"burst ballons permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Burst Ballons\"), mdx(\"p\", null, \"Given a list of scores of ballons A, each time burst a ballon at position i, get \", mdx(\"code\", {\n    parentName: \"p\",\n    \"className\": \"language-text\"\n  }, \"A[i-1]*A[i]*A[i+1]\"), \" points (score = 1 for outbound position).\\nreturn the maximum score.\"), mdx(\"p\", null, \"Bottom up dp + range dp from the last ballon burst, dp\", \"[i][j]\", \" is the maximum score could get in the range \", \"[i,j]\", \". Overall time complexity O(n^3)\"), mdx(\"h3\", {\n    \"id\": \"count-of-smaller-numbers-after-self\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#count-of-smaller-numbers-after-self\",\n    \"aria-label\": \"count of smaller numbers after self permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Count of smaller numbers after self\"), mdx(\"p\", null, \"Count of Smaller Numbers After Self, pretty straight forward. This is a pretty straight forward template of binary index tree also. (just shift the array)\\nFor other solutions, also merge sort, zkw tree, segment tree also works.\"), mdx(\"h3\", {\n    \"id\": \"shortest-distance-from-all-buildings\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#shortest-distance-from-all-buildings\",\n    \"aria-label\": \"shortest distance from all buildings permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Shortest distance from all buildings\"), mdx(\"p\", null, \"Given a 2D matrix with points indicating if the location is a building or obstacle or nothing. return the minimum distance to all buildings (or -1 if not possible).\\nFor all buildings, do BFS and get the shortest distance to other positions.\\nFor all possible points, add the shortest distance of each building, if all buildings can reach to that position.\"), mdx(\"h3\", {\n    \"id\": \"create-maximum-number\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#create-maximum-number\",\n    \"aria-label\": \"create maximum number permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Create Maximum Number\"), mdx(\"p\", null, \"Given two arrays containing only 0-9, return the k-digit maximum number we can get by choose numbers in these two arrays in order. Which means, if arr1\", \"[i]\", \" is chosen, all numbers before position i in arr1 can not be chosen, this is the only rule.\\nThere are some greedy solutions, but it's better to choose some other stupid but trustworthy ones.\\nThe idea is simple, first for each assignment of k, get the result of the maximum number we can get from arr1 and arr2 O(n^2)\\nThen merge the two arrays by two pointers O(n), and compare the result with previous ones.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Thinking: This problem can be extended to choose lexicographically largest string from two strings.\")));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"abstract":"","draft":null,"title":"Leetcode Hard Page 2","tags":["Leetcode","Leetcode hard"],"cover":"","date":"2022/02/04"}}},{"node":{"fields":{"slug":"/leetcode/leetcode-hard-page-4","date":"2022-02-04T05:00:00.000Z"},"excerpt":"Shortest Path Visiting All Nodes Given a undirected connected graph, get the shortest distance from any node to any node and\nmake sure every…","timeToRead":1,"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Leetcode Hard Page 4\",\n  \"cover\": \"\",\n  \"category\": \"Algorithm\",\n  \"date\": \"2022/02/04\",\n  \"abstract\": \"\",\n  \"tags\": [\"Leetcode\", \"Leetcode hard\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h3\", {\n    \"id\": \"shortest-path-visiting-all-nodes\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#shortest-path-visiting-all-nodes\",\n    \"aria-label\": \"shortest path visiting all nodes permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Shortest Path Visiting All Nodes\"), mdx(\"p\", null, \"Given a undirected connected graph, get the shortest distance from any node to any node and\\nmake sure every node is visited at least once. This is a pretty classic state compress dp problem.\\nWe can use a mask and a number representing which nodes are visited and which node is the last\\nin the path. Also, configuration map BFS can be applied by using similar state as a condition.\"), mdx(\"div\", {\n    \"className\": \"gatsby-highlight\",\n    \"data-language\": \"text\"\n  }, mdx(\"pre\", {\n    parentName: \"div\",\n    \"className\": \"language-text\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-text\"\n  }, \"n = len(graph)\\nfor i in range(n):\\n  graph[i] = set(graph[i]) # quick search, doesn't matter much\\n\\ndp = [[1e9]*n for _ in range(1<<n)]\\n\\nfor i in range(n): # initialization\\n  dp[1<<i][i] = 0\\n\\nfor i in range(1<<n):\\n  # update the current state\\n  for j in range(n):\\n    for k in range(n):\\n      if k != j and i & (1<<j) and i & (1<<k) and k in graph[j]:\\n        dp[i | (1<<k)][k] = min(dp[i | (1<<k)][k], dp[i][j] + 1)\\n  \\n  # update the next state\\n  for j in range(n):\\n    for k in range(n):\\n      if k != j and i & (1<<j) and (i & (1<<k) == 0) and k in graph[j]:\\n        dp[i | (1<<k)][k] = min(dp[i | (1<<k)][k], dp[i][j] + 1)\"))));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"abstract":"","draft":null,"title":"Leetcode Hard Page 4","tags":["Leetcode","Leetcode hard"],"cover":"","date":"2022/02/04"}}},{"node":{"fields":{"slug":"/leetcode/leetcode-hard-page-6","date":"2022-01-22T05:00:00.000Z"},"excerpt":"Purpose link to the following questions:  hard1499-1739 Stone Game IV To get if the first player can remove the last stone if two players…","timeToRead":1,"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Leetcode Hard Page 6\",\n  \"cover\": \"\",\n  \"category\": \"Algorithm\",\n  \"date\": \"2022/01/22\",\n  \"abstract\": \"\",\n  \"tags\": [\"Leetcode\", \"Leetcode hard\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h3\", {\n    \"id\": \"purpose\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#purpose\",\n    \"aria-label\": \"purpose permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Purpose\"), mdx(\"p\", null, \"link to the following questions: \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://leetcode.com/problemset/all/?sorting=W3sic29ydE9yZGVyIjoiREVTQ0VORElORyIsIm9yZGVyQnkiOiJESUZGSUNVTFRZIn1d&page=7\"\n  }, \"hard1499-1739\")), mdx(\"h3\", {\n    \"id\": \"stone-game-iv\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#stone-game-iv\",\n    \"aria-label\": \"stone game iv permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Stone Game IV\"), mdx(\"p\", null, \"To get if the first player can remove the last stone if two players take turns to remove #square number stones.\\nLet the function denote whether the current player is guaranteed to win or not if there are n stones left\\nIf the current player is the winner, the next player is not guaranteed to win in some of the next state.\"), mdx(\"div\", {\n    \"className\": \"gatsby-highlight\",\n    \"data-language\": \"text\"\n  }, mdx(\"pre\", {\n    parentName: \"div\",\n    \"className\": \"language-text\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-text\"\n  }, \"def dfs(n):\\n    i = 1\\n    while n-i**2 >= 0:\\n        # get next state\\n        if next player can not win in this state,then return true\\n        i += 1\"))));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"abstract":"","draft":null,"title":"Leetcode Hard Page 6","tags":["Leetcode","Leetcode hard"],"cover":"","date":"2022/01/22"}}},{"node":{"fields":{"slug":"/leetcode/leetcode-hard-page-1","date":"2022-01-18T05:00:00.000Z"},"excerpt":"Purpose This series of blog is to share some thoughts of hard questions in  leetcode . Generally, problems tagged as \"hard\" in leetcode…","timeToRead":9,"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Leetcode Hard Page 1\",\n  \"cover\": \"\",\n  \"category\": \"Algorithm\",\n  \"date\": \"2022/01/18\",\n  \"abstract\": \"\",\n  \"tags\": [\"Leetcode\", \"Leetcode hard\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h3\", {\n    \"id\": \"purpose\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#purpose\",\n    \"aria-label\": \"purpose permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Purpose\"), mdx(\"p\", null, \"This series of blog is to share some thoughts of hard questions in \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://leetcode.com/\"\n  }, \"leetcode\"), \". Generally, problems tagged as \\\"hard\\\" in leetcode varies in difficulty.\\nSome of them need heavy coding and complex corner cases, some of them need greedy solution which is way too intuitive, I don't like them so I might skip those.\\nIt's fun to dive deep into questions that can be solved by some specific way because people always wants to find a \\\"once for all\\\" solution.\\nAnd that is the purpose of my recording the solution of this questions.\"), mdx(\"p\", null, \"I will try to illustrate the ideas nice and clean, all the descriptions will follow a certain format:\\nWhat is the question? (generalized one or original one)\\nUsing which skills to solve which part of that question?\\nOther things to mention (may be trivial or skills that can not be categorized and or rarely)\"), mdx(\"p\", null, \"My target to enhance my skill to reduce a question to a specific model, anyway, it's interesting.\"), mdx(\"h3\", {\n    \"id\": \"median-of-two-sorted-arrays\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#median-of-two-sorted-arrays\",\n    \"aria-label\": \"median of two sorted arrays permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Median of Two Sorted Arrays\"), mdx(\"p\", null, \"This is to find the median in two sorted arrays, using \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"divide and conquer\"), \" to reduce the scope to search. Should use a recursive function.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"make sure we are always comparing number to number and index to index, for example normally we use 0-based index, if we want to know if the element with index of k can or can not be found within the first m elements, we should compare k+1 and m because both k+1 and m is the number, or k and m - 1. That's more reasonable to do it logically and can avoid silly off-by-one bugs.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"make sure this recursive function will come to an end, especially if we use \\\"mid index\\\" which is \\\"startIndex + endIndex + 1 >> 1\\\" or \\\"startIndex + endIndex >> 1\\\".\")), mdx(\"h3\", {\n    \"id\": \"regular-expression-matching\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#regular-expression-matching\",\n    \"aria-label\": \"regular expression matching permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Regular Expression Matching\"), mdx(\"p\", null, \"This is to match given string with a regular expression. We use \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"backtrack\"), \" to get the result.\"), mdx(\"h3\", {\n    \"id\": \"merge-k-sorted-lists\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#merge-k-sorted-lists\",\n    \"aria-label\": \"merge k sorted lists permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Merge k Sorted Lists\"), mdx(\"p\", null, \"This is to merge k sorted linkedlists in to one linkedlist. We use custom comparator and a \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"heap\"), \" to get the smallest result in the current heads of the given list.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"for python, we can define a class with \\\"\", \"_\", \"_lt\", \"_\", \"_(self,other)\\\" to do that trick (custom comparator)\")), mdx(\"h3\", {\n    \"id\": \"reverse-nodes-in-k-group\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#reverse-nodes-in-k-group\",\n    \"aria-label\": \"reverse nodes in k group permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Reverse Nodes in k-Group\"), mdx(\"p\", null, \"This is to reverse nodes k by k in a linkedlist. Reduce this question to \\\"reverse a linkedlist\\\".\"), mdx(\"h3\", {\n    \"id\": \"substring-with-concatenation-of-all-words\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#substring-with-concatenation-of-all-words\",\n    \"aria-label\": \"substring with concatenation of all words permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Substring with Concatenation of All Words\"), mdx(\"p\", null, \"To find the start index of a sequence which consists of all the words in a given list (may not be distinct) exactly once.\\nSo first build a \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"trie\"), \" with that list, then move back to the next position after match start when (\", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"discuss in different situations\"), \")\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"match complete\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"cur char not in trie\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"end of a trie node, but the number of current word is out of limit\")), mdx(\"h3\", {\n    \"id\": \"longest-valid-parentheses\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#longest-valid-parentheses\",\n    \"aria-label\": \"longest valid parentheses permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Longest Valid Parentheses\"), mdx(\"p\", null, \"To find the Longest Valid Parentheses subsequence in a string. \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Stack\"), \" and \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"dp\"), \" both work.\\nIf use dp, dp\", \"[i]\", \" is the longest \\\"single parenthese group\\\"(some thing like \\\"(())\\\" instead of \\\"(())()\\\"). After get the dp array, it's easy to get the longest continuous substring, just do a one time loop again. (Or you can do it inside the loop, this is why it's a dp solution)\\nIf use stack, just match the current ')' with previous '(' and add 2 which is the current pair into previous result, a easy trick in python is to store both '(' and number of matched pairs in a stack, that is more intuitive, otherwise store -1 into that stack is ok for other languages. The result is the running maximum of the current result.\"), mdx(\"h3\", {\n    \"id\": \"sudoku-solver\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#sudoku-solver\",\n    \"aria-label\": \"sudoku solver permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Sudoku Solver\"), mdx(\"p\", null, \"To solve a sudoku. Nothing special, \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"backtrack\"), \" and validate the final result.\"), mdx(\"h3\", {\n    \"id\": \"first-missing-positive\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#first-missing-positive\",\n    \"aria-label\": \"first missing positive permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"First Missing Positive\"), mdx(\"p\", null, \"To find the first missing positive in a unsorted array in O(n). Idea is based on \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"discussion in different situations\"), \", if the smallest missing positive is larger than 1, then our task is simple, just find the minimum positive number and minus one. Otherwise, the array must be somthing like \\\"1 2 7 10 20...\\\" when it is sorted. So we do a O(n) \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"index sort\"), \" for that array. This is to ensure elements with index within in the range of \", \"[1,len(A)]\", \" will be insert to the right position at least once.\"), mdx(\"h3\", {\n    \"id\": \"trapping-rain-water\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#trapping-rain-water\",\n    \"aria-label\": \"trapping rain water permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Trapping Rain Water\"), mdx(\"p\", null, \"To simulate a situation where rain falls into a 2D space. \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Stack\"), \" is used here to add water from the current position and previous position. And this is also a \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"monotonic queue\"), \" which maintains a decreasing sequence.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"only if there are two walls before the current wall, the water can be kept, this is the key for simulation\")), mdx(\"h3\", {\n    \"id\": \"wildcard-matching\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#wildcard-matching\",\n    \"aria-label\": \"wildcard matching permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Wildcard Matching\"), mdx(\"p\", null, \"To match the target string using a simplified regex expression including '*' and '?'. Using \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"dp\"), \" to represent\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"dp\", \"[i][j]\", \" (1-based index) whether pattern\", \"[1..j]\", \" matches str\", \"[1..i]\", \", if pattern\", \"[j]\", \" is '*', we only need to know whether pattern\", \"[1..j-1]\", \" matches any str\", \"[1..k]\", \" (k in \", \"[1..j]\", \")\")), mdx(\"h3\", {\n    \"id\": \"n-queensn-queens-ii\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#n-queensn-queens-ii\",\n    \"aria-label\": \"n queensn queens ii permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"N-Queens,N-Queens II\"), mdx(\"p\", null, \"No need to explain, classic backtrack.\"), mdx(\"h3\", {\n    \"id\": \"permutation-sequence\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#permutation-sequence\",\n    \"aria-label\": \"permutation sequence permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Permutation Sequence\"), mdx(\"p\", null, \"To get the k-th element of the permutation sequence of n. The number of elements with the same starting number is the same for each permutation and sub permutation.\\nSo just choose the first number and second number...based on how many k left. Any \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"recursive\"), \" function will work.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"better to use division instead of a while loop when we need to subtract a constant value from a total multiple times.\")), mdx(\"h3\", {\n    \"id\": \"valid-number\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#valid-number\",\n    \"aria-label\": \"valid number permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Valid Number\"), mdx(\"p\", null, \"To validate whether a string is valid as a number, scientific notation allowed. So this is a tipically problem with many corner cases, here I list some of them\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"code\", {\n    parentName: \"li\",\n    \"className\": \"language-text\"\n  }, \"\\\"+.\\\"\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"code\", {\n    parentName: \"li\",\n    \"className\": \"language-text\"\n  }, \"\\\"4e+\\\"\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"code\", {\n    parentName: \"li\",\n    \"className\": \"language-text\"\n  }, \"\\\"e\\\"\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"code\", {\n    parentName: \"li\",\n    \"className\": \"language-text\"\n  }, \"\\\".\\\"\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"code\", {\n    parentName: \"li\",\n    \"className\": \"language-text\"\n  }, \"\\\"+.1\\\"\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"code\", {\n    parentName: \"li\",\n    \"className\": \"language-text\"\n  }, \"\\\".e1\\\"\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"code\", {\n    parentName: \"li\",\n    \"className\": \"language-text\"\n  }, \"\\\"01\\\"\"))), mdx(\"h3\", {\n    \"id\": \"text-justification\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#text-justification\",\n    \"aria-label\": \"text justification permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Text Justification\"), mdx(\"p\", null, \"Give some words and a maxwidth. Output a list of lines showing how these words will be output in the screen.\\nFollowing the rules given by the question, it's complex but not hard actually.\"), mdx(\"h3\", {\n    \"id\": \"edit-distance\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#edit-distance\",\n    \"aria-label\": \"edit distance permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Edit distance\"), mdx(\"p\", null, \"Give two strings. Find the minimum number of modifications (add,delete,replace) of one string to change it into another.\\nUsing \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"dp\"), \" to solve it. dp\", \"[i][j]\", \" means the minimum step of operation to change str1\", \"[1..i]\", \" to str2\", \"[1..j]\"), mdx(\"p\", null, \"Part of my python code is\"), mdx(\"div\", {\n    \"className\": \"gatsby-highlight\",\n    \"data-language\": \"text\"\n  }, mdx(\"pre\", {\n    parentName: \"div\",\n    \"className\": \"language-text\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-text\"\n  }, \"for i in range(1,n+1):\\n    for j in range(1,m+1):\\n        c1,c2 = word1[i-1],word2[j-1]\\n        if c1 == c2:\\n            dp[i][j] = dp[i-1][j-1]\\n        else:\\n            dp[i][j] = min(dp[i-1][j],dp[i][j-1],dp[i-1][j-1]) + 1\"))), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"it seems like many dp problem for strings need 1-based index and some initialization step to make the meaning correct\")), mdx(\"h3\", {\n    \"id\": \"minimum-window-substring\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#minimum-window-substring\",\n    \"aria-label\": \"minimum window substring permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Minimum Window Substring\"), mdx(\"p\", null, \"Give a target string and base string, find a substring (of base string) to ensure it covers the target string when re-arranged.\\nUsing \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"sliding window\"), \", in each step, there should a variable indicating whether the condition is meet or not.\\nI used a set to store all the necessary characters in the target and another map to change that set.\\nThis \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://leetcode.com/problems/minimum-window-substring/discuss/26804/12-lines-Python\"\n  }, \"post\"), \" use a map (shared with previous count map) and a number to do this.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Before determining the current interval is valid or not, for the end index, there are two \\\"sliding window\\\" boilerplates for us to use:\")), mdx(\"div\", {\n    \"className\": \"gatsby-highlight\",\n    \"data-language\": \"text\"\n  }, mdx(\"pre\", {\n    parentName: \"div\",\n    \"className\": \"language-text\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-text\"\n  }, \"start = 0\\nfor end in 1...n\\n  update with new end\\n  if [start..end] is valid:\\n    while start < end and [start + 1..end] is still valid:\\n      update   //start is removed\\n      start ++ \\n    \\n    [start...end] is the smallest window ending in end    \"))), mdx(\"p\", null, \"Or we can have another structure using while\"), mdx(\"div\", {\n    \"className\": \"gatsby-highlight\",\n    \"data-language\": \"text\"\n  }, mdx(\"pre\", {\n    parentName: \"div\",\n    \"className\": \"language-text\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-text\"\n  }, \"start,end = 0,0\\nupdate\\nwhile end <n:\\n  if [start...end] is valid:\\n    [start...end] may be the smallest window ending in end\\n\\n    update // start is removed\\n    start++\\n    \\n    if start > end:\\n      update // start + 1 is added\\n      end += 1\\n  else:\\n    end += 1\\n    update // end + 1 is added\"))), mdx(\"p\", null, \"Choosing which template depends on **Whether calculating the validity of the next step is costly or not\\\".\\nFor example, if we know \", \"[start..end]\", \" is valid, and we want to know if \", \"[start+1..end]\", \" is valid or not, if this operation is complex, then we choose the second one. Otherwise, the first one is cleaner and easier.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"notice in the second template, start + 1 or end + 1 may not exist, so we need some additional if condition\")), mdx(\"h3\", {\n    \"id\": \"largest-rectangle-in-histogram\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#largest-rectangle-in-histogram\",\n    \"aria-label\": \"largest rectangle in histogram permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Largest Rectangle in Histogram\"), mdx(\"p\", null, \"To get the maximum rectangle size with in a histogram with postive integer coordinates. Using \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"stack\"), \" to solve it.\\nWhen using \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"stack\"), \" to solve these kind of specific question, there are some certain things that should consider:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Which info we have at every step and what should we store in the stack?\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"What is the property of the stack in each loop? Are we going to maintain a monotonic queue? increasing? decreasing?\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Which info can be compressed or throwed? For example if we pop elements from a stack,\\nwe are compressing the info of these elements to the last element of that stack or just throw it away.\\nIn this question, we maintain a monotonic increasing queue, and for each new element smaller than previous one,\\nwe pop out the previous one and calculate if we extend the current element(the smaller one) to this element, what is the size\\nof the rectangle. This is the maximum one because what we have is a monotonic queue and it can not be extended further left.\\nSo for each element, we know how long it can be extended to the left and we got the result.\")), mdx(\"h3\", {\n    \"id\": \"maximum-rectange\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#maximum-rectange\",\n    \"aria-label\": \"maximum rectange permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Maximum Rectange\"), mdx(\"p\", null, \"To get the maximum rectange full of 1 inside a matrix of 1 and 0.\\nFor each row, this is the same to Largest Rectangle in Histogram, we only need to find the ending of each \\\"histogram\\\" in each row.\"), mdx(\"h3\", {\n    \"id\": \"closest-binary-search-tree-value-ii-follow-up\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#closest-binary-search-tree-value-ii-follow-up\",\n    \"aria-label\": \"closest binary search tree value ii follow up permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Closest Binary Search Tree Value II (follow up)\"), mdx(\"p\", null, \"To get the first k numbers in a binary tree closest to the given target. Actually if k = n, the time complexity is O(n) since the result array has n elements.\\nBut we can do it in O(klogn) by finding the closest number in a loop. The idea is to find the maximum number smaller(or equals) to k and the minimum number larger(or equals) to k.\"), mdx(\"p\", null, \"And we tag the nodes by binary index to identify whether this node is used or not. There is some \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"discussion in different situations\"), \". \"), mdx(\"h3\", {\n    \"id\": \"strobogrammatic-number-iii\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#strobogrammatic-number-iii\",\n    \"aria-label\": \"strobogrammatic number iii permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Strobogrammatic Number III\"), mdx(\"p\", null, \"Find number within \", \"[low,high]\", \" ensuring the number is the same when rotated 180 degrees. This can be solved faster through complex logic, but for questions relating to symmetric reasoning.\\nIt's better to \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"disscuss in different situations\"), \" for whether it's odd or even. Here we just generate all possible answers and check whether it's within low and high or not. \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"dp\"), \" is a possible way to do that, \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"dfs\"), \" also works. \"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Mention the leading zero is not a big issue if we need to convert the whole number, just add '0' into the interval result and ignore it at last.\")), mdx(\"h3\", {\n    \"id\": \"paint-house-ii\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#paint-house-ii\",\n    \"aria-label\": \"paint house ii permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Paint House II\"), mdx(\"p\", null, \"Paint house with a cost matrix (paint house i with color j costs cost\", \"[i][j]\", \"), with no two adjacent houses share the same color.\\ndp\", \"[i][j]\", \" = minimum cost from 0-i with house i of color j, result is min(dp\", \"[-1]\", \")\"), mdx(\"h3\", {\n    \"id\": \"alien-dictionary\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#alien-dictionary\",\n    \"aria-label\": \"alien dictionary permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Alien Dictionary\"), mdx(\"p\", null, \"Given a list of words sorted by a certain order (like a<b<c<d... or z<f<k<g...), get that order.\\nWe can get a certain order by two adjacent words, this order can be represented by an directed edge, finally we can get a graph. if it is a DAG, then we have the result by its topo order.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Mention two adjacent words could be illegal such as 'ab' followed by 'a'\")), mdx(\"h3\", {\n    \"id\": \"closest-binary-search-tree-value-ii\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#closest-binary-search-tree-value-ii\",\n    \"aria-label\": \"closest binary search tree value ii permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Closest Binary Search Tree Value II\"), mdx(\"p\", null, \"Get k values closest the target in a Binary Search Tree. A simple solution is traverse + two pointers, which is O(n). But for the follow up, the way to do it in O(klogn) can be:\\nFor each round, we select the maximum value smaller than target and minimum value greater than target. Compare their abs value and set a visited flag to the node with smaller abs value. The next round, if we encounter a node we visited in \\\"find the maximum value smaller than target\\\", we go to the left node, because we it's right child must have been visited before. It's the same for the right side.\"), mdx(\"h3\", {\n    \"id\": \"expression-add-operators\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#expression-add-operators\",\n    \"aria-label\": \"expression add operators permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Expression Add Operators\"), mdx(\"p\", null, \"Given a string of digits only, add '+-*' in any position between digits to make the expression value to equal to a target.\\nBacktrack and try each possible position.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Mention if we only generating different expressions and evaluate them, there will be TLE.\\nWe should at least get all the numbers we are using and put them in a stack and backtrack that stack.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Or we can calculate during backtrack which is complex but fast\", mdx(\"blockquote\", {\n    parentName: \"li\"\n  }, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://leetcode.com/problems/expression-add-operators/discuss/572099/C%2B%2BJavaPython-Backtracking-and-Evaluate-on-the-fly-Clean-and-Concise\"\n  }, \"https://leetcode.com/problems/expression-add-operators/discuss/572099/C%2B%2BJavaPython-Backtracking-and-Evaluate-on-the-fly-Clean-and-Concise\"))))), mdx(\"p\", null, \"Core code, idea is to add previous number as default, and subtract from the sum when \", \"*\", \" is added behind\"), mdx(\"div\", {\n    \"className\": \"gatsby-highlight\",\n    \"data-language\": \"python\"\n  }, mdx(\"pre\", {\n    parentName: \"div\",\n    \"className\": \"language-python\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"backtrack\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"(\"), \"j \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token operator\"\n  }, \"+\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token number\"\n  }, \"1\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \",\"), \" path \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token operator\"\n  }, \"+\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token string\"\n  }, \"\\\"*\\\"\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token operator\"\n  }, \"+\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token builtin\"\n  }, \"str\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"(\"), \"num\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \")\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \",\"), \" resultSoFar \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token operator\"\n  }, \"-\"), \" prevNum \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token operator\"\n  }, \"+\"), \" prevNum \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token operator\"\n  }, \"*\"), \" num\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \",\"), \" prevNum \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token operator\"\n  }, \"*\"), \" num\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \")\")))), mdx(\"h3\", {\n    \"id\": \"find-median-from-data-stream\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#find-median-from-data-stream\",\n    \"aria-label\": \"find median from data stream permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Find Median from Data Stream\"), mdx(\"p\", null, \"Given a stream of numbers, find the median in O(logn) time. An idea is to maintain two heaps, one is a min heap and the other is a max heap.\\nAnd maintain the size of two heaps has difference less than two. Or we can use segment tree and binary search to find kth element of the data stream.\\nThis is an overkill for such problems(But for this problem, it's slower since it's O(logn * logn)).\"), mdx(\"h3\", {\n    \"id\": \"best-meeting-point\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#best-meeting-point\",\n    \"aria-label\": \"best meeting point permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Best Meeting Point\"), mdx(\"p\", null, \"Given a grid with some points, return the minimum Manhattan Distance from any node to all these nodes. The chosen node and these nodes can overlap.\\nThe answer is pretty simple, the coordinate x,y of the chosen point is just the median of all the xs and ys.\\nThere is an intuitive idea about that:\\n\", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"gatsby-resp-image-wrapper\",\n    \"style\": {\n      \"position\": \"relative\",\n      \"display\": \"block\",\n      \"marginLeft\": \"auto\",\n      \"marginRight\": \"auto\",\n      \"maxWidth\": \"468px\"\n    }\n  }, \"\\n      \", mdx(\"a\", {\n    parentName: \"span\",\n    \"className\": \"gatsby-resp-image-link\",\n    \"href\": \"/static/2beaba8ab12c20ddd75b529ce6fef0d7/90372/bestmeetingpoint.png\",\n    \"style\": {\n      \"display\": \"block\"\n    },\n    \"target\": \"_blank\",\n    \"rel\": \"noopener\"\n  }, \"\\n    \", mdx(\"span\", {\n    parentName: \"a\",\n    \"className\": \"gatsby-resp-image-background-image\",\n    \"style\": {\n      \"paddingBottom\": \"63.51351351351351%\",\n      \"position\": \"relative\",\n      \"bottom\": \"0\",\n      \"left\": \"0\",\n      \"backgroundImage\": \"url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABgElEQVQ4y4VT2W7CQAzM/39am4e2eaNAjj1CCDeEHJBMNaamCBBdaeTdlWcy69hB0zQg2rZF13UCvXuFuq4FuiePKyjLEtvtFrvdDlVVgef1eo3NZiNRsVqtJC4WCxRFIedbeO/R9z0CVdZFp6/WMAxPc2jgdDohoF1N5Nrv9/KlF4q45SiP7s/nMwLaZQKfyy+HYYiPzy84nyPNDDJjr7DOy50xFk1z4RDkswwieDwe5Qvqyvsc42mCzHrEqUGS2Ssy6zCJUxFWzoPD+yez6MZ5WJfDWA/jclg/g8sLuaNwPps9PJk1fCo4L0txRoepcb/OLntGnoti/lBadooIUpm149P5x611GH2PMY0TTOIE42mMiSCR+r29h4iiSMjk0BD5fJm0DYvKDX85kw6Hg8Rh6DH0f9B6NXUtfccccpR3reF9H7Lz/1vP+pDtJoJUpnU6ZVwul+KSe8XtmPFMDkV1ZOmSPBHkyLGgrKWOm44TkwjWR8HRZM8xEnpPQ5zlH1Ee6aAg8hNkAAAAAElFTkSuQmCC')\",\n      \"backgroundSize\": \"cover\",\n      \"display\": \"block\"\n    }\n  }), \"\\n  \", mdx(\"img\", {\n    parentName: \"a\",\n    \"className\": \"gatsby-resp-image-image\",\n    \"alt\": \"idea\",\n    \"title\": \"idea\",\n    \"src\": \"/static/2beaba8ab12c20ddd75b529ce6fef0d7/90372/bestmeetingpoint.png\",\n    \"srcSet\": [\"/static/2beaba8ab12c20ddd75b529ce6fef0d7/12f09/bestmeetingpoint.png 148w\", \"/static/2beaba8ab12c20ddd75b529ce6fef0d7/e4a3f/bestmeetingpoint.png 295w\", \"/static/2beaba8ab12c20ddd75b529ce6fef0d7/90372/bestmeetingpoint.png 468w\"],\n    \"sizes\": \"(max-width: 468px) 100vw, 468px\",\n    \"style\": {\n      \"width\": \"100%\",\n      \"height\": \"100%\",\n      \"margin\": \"0\",\n      \"verticalAlign\": \"middle\",\n      \"position\": \"absolute\",\n      \"top\": \"0\",\n      \"left\": \"0\"\n    },\n    \"loading\": \"lazy\",\n    \"decoding\": \"async\"\n  }), \"\\n  \"), \"\\n    \"), \"\\nFor any two points, the chosen point with minimum distance must in the shaded area. Even if we project that two points in the edges, the result will\\nstill be the same. So for all the points, we project them to edges and the result is obviously the median of all xs and ys.\"), mdx(\"h3\", {\n    \"id\": \"remove-invalid-parentheses\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#remove-invalid-parentheses\",\n    \"aria-label\": \"remove invalid parentheses permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Remove invalid parentheses\"), mdx(\"p\", null, \"Given a string s that contains parentheses and letters, remove the minimum number of invalid parentheses to make the input string valid.\"), mdx(\"p\", null, \"My solution is quite lengthy and now doable in an interview, here is a version which I believe is simple and easy to implement\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://leetcode.com/problems/remove-invalid-parentheses/discuss/459218/Python-solution-using-Smart-Backtracking-with-a-Simple-Trick-Beats-82-in-Time-and-100-in-Space\"\n  }, \"https://leetcode.com/problems/remove-invalid-parentheses/discuss/459218/Python-solution-using-Smart-Backtracking-with-a-Simple-Trick-Beats-82-in-Time-and-100-in-Space\")), mdx(\"ul\", {\n    parentName: \"blockquote\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Mention when removing ')', we must ensure we are not removing the last ')' of an expression like '((())', even if rightsToRemove > 0.\"))));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"abstract":"","draft":null,"title":"Leetcode Hard Page 1","tags":["Leetcode","Leetcode hard"],"cover":"","date":"2022/01/18"}}}]}},"pageContext":{"tag":"Leetcode hard"}},
    "staticQueryHashes": []}