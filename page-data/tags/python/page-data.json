{"componentChunkName":"component---src-templates-tag-jsx","path":"/tags/python/","result":{"data":{"allMarkdownRemark":{"totalCount":1,"edges":[{"node":{"fields":{"slug":"/algorithm/python-implementation-of-koch-snowflake","date":"2019-10-22T04:00:00.000Z"},"excerpt":"Koch Curve（Koch Snowflake）\nhttps://www.geeksforgeeks.org/koch-curve-koch-snowflake/ 简介： 科赫雪花（科赫曲线）是最早发现的分形曲线之一，由瑞典科学家 Helge von Koch…","timeToRead":3,"rawMarkdownBody":"\r\nKoch Curve（Koch Snowflake）\r\nhttps://www.geeksforgeeks.org/koch-curve-koch-snowflake/\r\n\r\n简介：\r\n\r\n科赫雪花（科赫曲线）是最早发现的分形曲线之一，由瑞典科学家 Helge von Koch 在论文中构造\r\n\r\n科赫雪花的面积趋向于原始三角形的8/5，而周长趋向无穷大\r\n\r\n构造过程：\r\n![原始三角形](./Koch-Snowflake-1.jpg)\r\n![原始三角形](./Koch-Snowflake-2.jpg)\r\n![每边三等分](./Koch-Snowflake-3.jpg)\r\n![在三等分点上构建新三角形](./Koch-Snowflake-4.jpg)\r\n![继续每边三等分](./Koch-Snowflake-5.jpg)\r\n![继续在三等分点上构建新三角形](./Koch-Snowflake-6.jpg)\r\n...\r\n\r\n科赫雪花可一通过下列规则描述\r\n[rewrite system](https://en.wikipedia.org/wiki/Rewriting) ([Lindenmayer system](https://en.wikipedia.org/wiki/Lindenmayer_system)):\r\n**Alphabet** : F\r\n**Constants** : +, ?\r\n**Axiom **: F\r\n**Production rules**: F ? F+F–F+F\r\n\r\n程序实现\r\n\r\n思路1：\r\n首先我们把三条边分开处理\r\n考虑深度为0的情况，显然这条边是一条直线\r\n考虑深度为1的情况，轨迹如下：\r\n![](./Koch-Snowflake-7.jpg)\r\n\r\n我们把这个轨迹抽象为“前进”方法，我们就有变成了深度为1的前进方法 = 深度为0的前进方法 x4 \r\n同理我们发现，深度为2的前进方法 = 深度为1的前进方法 x4\r\n观察到问题的复杂度在不断降低，可以使用递归来处理这样的规律\r\n\r\n```python\r\nfrom turtle import *\r\ndef snowflake(lengthSide, levels): \r\n    if levels == 0: \r\n        forward(lengthSide) \r\n        return\r\n    lengthSide /= 3.0\r\n    snowflake(lengthSide, levels-1) \r\n    left(60) \r\n    snowflake(lengthSide, levels-1) \r\n    right(120) \r\n    snowflake(lengthSide, levels-1) \r\n    left(60) \r\n    snowflake(lengthSide, levels-1) \r\n\r\n# main function \r\nif __name__ == \"__main__\": \r\n    speed(0)                    \r\n    length = 300.0          \r\n\r\n    #分别处理三条边\r\n    for i in range(3):     \r\n        snowflake(length, 4) \r\n        right(120) \r\n    exitonclick()     \r\n```\r\n\r\n\r\n思路2\r\n把第0层画的线用0表示，第1层用1表示，那么根据画笔的轨迹我们有\r\n第0层（三角形） 000\r\n第1层                   011001100110\r\n第2层                   022012211221022002201221122102200220122112210220\r\n![第1层，其余类似](./Koch-Snowflake-8.jpg)\r\n\r\n显然，把上一层的节点复制一遍，中间插入两个当前层次的节点即可。连续相同节点逆时针转120度，非连续相同节点逆时针转60度\r\n```python\r\nfrom turtle import *\r\ndef draw(len,target):\r\n    tasks=\"000\"\r\n    step,depth = len/(3**target),0\r\n    while depth<target:\r\n        depth+=1\r\n        tasks = ''.join([s+str(depth)*2+s for s in tasks])\r\n    pre=''\r\n    for task in tasks:\r\n        if pre==task:\r\n            right(120)\r\n        else:\r\n            left(60)\r\n        forward(step)\r\n        pre = task\r\n\r\nlength = 300.0\r\ndraw(length,3)\r\n```","frontmatter":{"abstract":"Koch Curve（Koch Snowflake）","draft":null,"title":"Python Implementation of Koch Snowflake","tags":["中文","algorithm","python"],"cover":"","date":"2019/10/22"}}}]}},"pageContext":{"isCreatedByStatefulCreatePages":false,"tag":"python"}}}