{"componentChunkName":"component---src-templates-tag-jsx","path":"/tags/combination/","result":{"data":{"allMarkdownRemark":{"totalCount":1,"edges":[{"node":{"fields":{"slug":"/algorithm/combinations-and-permutations","date":"2019-10-20T04:00:00.000Z"},"excerpt":"问题 排列（Permutation）：求1,2,3...n的不同排列方式（n!） 思路 普通的排列问题，在python…","timeToRead":5,"rawMarkdownBody":"### 问题\r\n排列（Permutation）：求1,2,3...n的不同排列方式（n!）\r\n### 思路\r\n普通的排列问题，在python库中甚至有现成的库可以用来解决，我们这里考虑两种方案，首先是回溯的思路（递归）：\r\n基于交换元素的回溯实现较为简单，每一次交换循环位置的元素和首元素，直到循环位置抵达末尾，交换完毕后回溯\r\n\r\n可能为什么要用交换来求排列看上去比较难理解，那么考虑用最原始的方式，即选择任意元素作为第一个元素，再选择除第一个元素以外的任意一个作为第二个元素。。。\r\n\r\n如果我们要记录所选元素是否被选择过，需要使用一个布尔数组，但其实我们可以直接把选择过的元素放在当前位置上，然后只记录起始位置\r\n\r\n选择其他元素之前，把这个元素放回来就行了（如果使用布尔数组记录，其实也需要这个回溯过程）\r\n\r\n其次是非递归的实现，首先给出一个基于递归栈的实现\r\n\r\n思路是通过用栈模拟交换，记录需要交换的元素位置，并把下一轮需要交换的元素以及数组的拷贝放进栈中\r\n\r\n另一种非递归实现的思路是基于n!的计算，时间复杂度为O(n!)，不过比上面的非递归要快一点\r\n\r\n既然一共有n!个排列，那么n的排列相当于n-1的所有排列*n，得到n-1的所有排列后，其实只需在每种排列上加上1-n就行了\r\n\r\n\r\n### 解决\r\n```python\r\n# 递归\r\ndef rec(a, l, r):\r\n    if l==r:\r\n        print(*a)\r\n        return\r\n    for i in range(l, r+1):#注意这里下限是l，虽然把自己跟自己交换是一种重复，但这也是需要计算在内的\r\n        a[i], a[l] = a[l], a[i]\r\n        rec(a,l+1,r)\r\n        a[i], a[l] = a[l], a[i]\r\nrec([i+1 for i in range(n)], 0, n-1)\r\n```\r\n\r\n```python\r\n# 非递归  - 1\r\ndef non_rec(a):\r\n    n = len(a)\r\n    result, r = [], [[a,-1,-1]]\r\n    while len(r)>0:\r\n        ra, ri, rt = r.pop()\r\n        ra[ri], ra[rt] = ra[rt], ra[ri]\r\n        if ri==n-1:\r\n            result.append(ra)\r\n        for nrt in range(ri+1,n):\r\n            r.append([ra[:],ri+1,nrt])\r\n    return result\r\n```\r\n\r\n```python\r\n# 非递归 - 2\r\ndef non_rec(a):\r\n    n = len(a)\r\n    result, t, steps = [], 1, [[a[0]]]\r\n    while t < n:\r\n        cur = []\r\n        for step in steps:\r\n            for i in range(t+1):\r\n                newStep = step[:]\r\n                newStep.insert(i,a[t])\r\n                cur.append(newStep)\r\n        steps = cur\r\n        t+=1\r\n        if t==n:\r\n            result = steps\r\n    return result\r\n```\r\n\r\n### 问题\r\n组合（Combination）：求1-n中取出x个数字的方式（C(n,x)）\r\n### 思路\r\n同样考虑两种方式，首先是递归，记录当前位置和递归深度即可，递归深度为x即取数完毕\r\n\r\n第二是非递归，这里运用了一点bit magic，大概意思是根据x二进制中最大递增后缀序列求出下一个排列，具体可以参见[这篇文章](http://blog.gaurav.im/2016/12/18/next-binary-permutation-bitwise-hackery/)\r\n\r\n### 解决\r\n```python\r\n# 递归\r\ndef comb(n,x,cur,start,depth,arr):\r\n    if depth==x:\r\n        arr.append(cur)\r\n        return\r\n    for next in range(start,n-x+depth+1):\r\n        comb(n,x,cur+str(next),next+1,depth+1,arr)\r\ncomb(n,x,'',0,0,arr) # 01 02 03 04 12 13 14 23 24 34，这里下标是0开始的，不影响效果\r\n```\r\n```python\r\n# 非递归\r\nn, x = 5, 3\r\nstart, end = (1 << c)-1, (1 << n) - (1 << (n-x)) # 这里start和end就是二进制中x个1在最开始和最末尾的数\r\nv = start\r\nwhile v <= end:\r\n    # 这里结果所对应的二进制位为1的下标就是具体的组合\r\n    print(bin(v)[2:].rjust(n, '0'))\r\n    # 下面两行是求next permutation的位运算方法，具体解释可以参考引用的两篇资料\r\n    t = (v | (v - 1)) + 1 \r\n    w = t | ((int((t & -t) / (v & -v)) >> 1) - 1)\r\n    v = w\r\n```\r\n\r\n### Ref\r\nhttps://www.geeksforgeeks.org/write-a-c-program-to-print-all-permutations-of-a-given-string/\r\nhttp://blog.gaurav.im/2016/12/18/next-binary-permutation-bitwise-hackery/\r\nhttps://graphics.stanford.edu/~seander/bithacks.html#NextBitPermutation\r\n\r\n### Tips\r\n- x & -x是求x的二进制中最右边的1所对应位置的二进制数，比如x=01100100，x&-x=00000100，x为奇数这个值就一定是1\r\n- x | x-1是将x的二进制中所有后继0置1，比如x=01100100，x&-x=01100111，同样x为奇数这个值就是本身","frontmatter":{"abstract":"排列和组合","draft":null,"title":"Combinations and Permutations","tags":["中文","algorithm","combination","permutation","bitwise"],"cover":"","date":"2019/10/20"}}}]}},"pageContext":{"isCreatedByStatefulCreatePages":false,"tag":"combination"}}}