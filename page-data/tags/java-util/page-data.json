{"componentChunkName":"component---src-templates-tag-jsx","path":"/tags/java-util/","result":{"data":{"allMarkdownRemark":{"totalCount":1,"edges":[{"node":{"fields":{"slug":"/Java/java-multi-thread-utils","date":"2019-07-07T04:00:00.000Z"},"excerpt":"notify wait wait()、notify()和notifyAll()是Object类中的native final方法（除重载），这两个方法是为了解决多线程环境下的竞态环境，必须在同步方法块内调用 notify,notifyAll…","timeToRead":13,"rawMarkdownBody":"### notify wait\r\nwait()、notify()和notifyAll()是Object类中的native final方法（除重载），这两个方法是为了解决多线程环境下的竞态环境，必须在同步方法块内调用\r\n\r\n- notify,notifyAll 唤起其他等待锁的线程，但并不会立刻切换到其他线程，而是等到执行完同步代码块之后再进行切换，使用notify会唤起最先等待的线程，notifyAll会唤起所有等待的线程\r\n\r\n- wait 使当前线程阻塞，释放所持有的锁（不必等到同步代码块结束）\r\n\r\n- 不建议直接使用notify wait进行多线程编程\r\n\r\n模拟使用notify的场景：两个线程竞争同一资源\r\n```java\r\n\r\n//two threads competing for one resource\r\npublic class CompetingThread {\r\n    Thread[] threads;\r\n\r\n    CompetingThread(Thread[] threads){\r\n        this.threads= threads;\r\n    }\r\n\r\n    public void get() {\r\n        Thread t1 = threads[0], t2 = threads[1];\r\n        System.out.println(\"Ready to Get\");\r\n        synchronized (this){\r\n            System.out.println(Thread.currentThread().getName()+\" Got the lock\");\r\n\r\n            System.out.println(\"Now, \"+t1.getName()+\" is \"+t1.getState()+\", \"+t2.getName()+\" is \"+t2.getState());\r\n            System.out.println(\"notify() to release the lock after all done\");\r\n            System.out.println(\"Do sth. before notify is just the same as after\");\r\n            notify();\r\n            System.out.println(\"Do sth. after notify is just the same as before\");\r\n            System.out.println(Thread.currentThread().getName()+\" is done.\");\r\n        }\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n        Thread[] threads = new Thread[2];\r\n        CompetingThread competingThread = new CompetingThread(threads);\r\n        threads[0] = new Thread(()->competingThread.get());\r\n        threads[1] = new Thread(()->competingThread.get());\r\n        threads[0].start();\r\n        threads[1].start();\r\n    }\r\n}\r\n\r\n```\r\n\r\n输出\r\n\r\n```text\r\n//output\r\n\r\nReady to Get\r\nReady to Get\r\nThread-0 Got the lock\r\nNow, Thread-0 is RUNNABLE, Thread-1 is BLOCKED\r\nnotify() to release the lock after all done\r\nDo sth. before notify is just the same as after\r\nDo sth. after notify is just the same as before\r\nThread-0 is done.\r\nThread-1 Got the lock\r\nNow, Thread-0 is TERMINATED, Thread-1 is RUNNABLE\r\nnotify() to release the lock after all done\r\nDo sth. before notify is just the same as after\r\nDo sth. after notify is just the same as before\r\nThread-1 is done.\r\n```\r\n模拟使用wait和notify(notifyAll)的场景：顾客在餐厅点餐，服务员等候（BLOCKING），点餐完毕，顾客等候上菜（wait()），服务员上菜，告知顾客菜来了（notify()）\r\n```java\r\npublic class WaitNotifyExample {\r\n    public static Object menu = new Object();\r\n\r\n    public static void main(String[] args) {\r\n        Thread customer = new Thread() {\r\n            @Override\r\n            public void run() {\r\n                synchronized (menu) {\r\n                    System.out.println(\"Customer: I'm reading menu, please wait\");\r\n                    try {\r\n                        Thread.sleep(1000);\r\n                        System.out.println(\"Customer: These are my orders.(waiting for the meal)\");\r\n                        menu.wait();\r\n                    }catch (InterruptedException e){}\r\n                    System.out.println(\"Customer: Oh, these are my foods!\");\r\n                }\r\n            }\r\n        };\r\n\r\n        Thread waiter = new Thread(){\r\n            @Override\r\n            public void run(){\r\n                System.out.println(\"Waiter: (Waiting for customer's orders)\");\r\n                synchronized (menu){\r\n                    System.out.println(\"Waiter: Gonna prepare you meal, sir.\");\r\n                    try {\r\n                        Thread.sleep(1000);\r\n                        menu.notify();//notifyAll if there are more than 1 customer\r\n                        System.out.println(\"Waiter: Your foods are ready.\");\r\n                    }catch (InterruptedException e){}\r\n                }\r\n            }\r\n        };\r\n\r\n        customer.start();\r\n        waiter.start();\r\n    }\r\n}\r\n```\r\n输出\r\n```text\r\n//output\r\n\r\nCustomer: I'm reading menu, please wait\r\nWaiter: (Waiting for customer's orders)\r\nCustomer: These are my orders.(waiting for the meal)\r\nWaiter: Gonna prepare you meal, sir.\r\nWaiter: Your foods are ready.\r\nCustomer: Oh, these are my foods!\r\n\r\n```\r\n\r\n### CountDownLatch\r\n一个线程安全的倒计时器，在倒计时为0前，令线程等待（getState()：WAITING）\r\n\r\n使用步骤：\r\n- 构造一个容量为10的倒计时器 `CountDownLatch latch = new CountDownLatch(10)`\r\n- 主线程中调用`latch.await()`，等待相关线程进行倒计时\r\n- 不同的线程中调用该倒计时器实例的`latch.countDown()`方法，进行倒计时\r\n- 当latch的倒计时为0时，主线程恢复运行\r\n\r\n### ReentrantLock\r\nReentrantLock(Re-entrantLock)是一个基于AQS（AbstractQueuedSynchronizer）高性能工具，支持线程在未释放锁的情况下重复获取锁\r\n#### API\r\n方法 | 解释\r\n---|---\r\nlock | holdCount+1，并给当前线程加锁\r\nunlock | holdCount-1，holdCount为0时，释放资源\r\ntryLock | 如果资源锁不在其他线程中，返回true，holdCount+1，否则返回false，不过线程并不会阻塞\r\nlockInterruptibly() | 锁空闲的情况下正常获取，但是允许被其他线程的请求中断\r\ngetHoldCount | 获取holdCount，注意如果持有锁的不是本线程，则直接返回0\r\n\r\n#### 原理概述\r\nReentrantLock的可重入功能基于AQS的同步状态：state（可通过getHoldCount获取）。当某一线程获取锁后，holdCount+1，并记录下当前持有锁的线程，再有线程来获取锁时，判断这个线程与持有锁的线程是否是同一个线程，如果是，holdCount+1，如果不是，阻塞线程。\r\n当线程释放锁时，holdCount-1，holdCount为0时，唤醒其他线程，使其重新竞争锁。\r\n\r\n#### 解决问题\r\n\r\n- 解决synchronized在竞争激烈场景下的性能问题\r\n>在锁竞争不激烈的时候，多数情况下锁会停留在偏向锁和轻量级锁阶段,这两个阶段下，synchronized性能很好，但当存在大量线程竞争锁时，可能会膨胀为重量级锁，性能下降，ReentrantLock的性能会优于synchronized。不过在JDK1.6之后，synchronized进行了优化，大多数场景下性能与ReentrantLock所差无几\r\n\r\n- 填补其他synchronized的缺陷\r\n>一旦线程卡在等待锁的阶段，就有可能出现死锁\r\n\r\n>不可响应中断\r\n\r\n>不能尝试获取锁\r\n\r\n#### ReentrantLock VS synchronized\r\n>对多线程操作支持情况和实现方式（如果支持的话）\r\n\r\n项目\\锁 | synchronized | \tReentrantLock\r\n---|---|---\r\n公平性|只支持非公平锁 | 支持公平锁和非公平锁\r\n是否支持尝试获取锁|不支持|支持 tryLock(time, TimeUnit)\r\n是否可响应中断|不支持|支持 lockInterruptibly\r\n等待条件|支持 notify wait | 支持 Condition\r\n\r\n\r\n#### ReentrantLock Example\r\ntryLock，lock，lockInterruptibly的对比测试，runnableWork是一个耗时操作，目的是让线程状态保持在RUNNABLE\r\n```java\r\npublic class ReentrantLockAPI {\r\n    public static void runnableWork(){\r\n        for (int i = 0; i < 1000; i++) {\r\n            for (int j = 0; j < 1000; j++) {\r\n                for (int k = 0; k < 1000; k++) {\r\n\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    public static void lockInterruptibly_tryLock_API(){\r\n        final ReentrantLock lock = new ReentrantLock();\r\n        Thread interruptibleThread = new Thread(()->{\r\n            try {\r\n                runnableWork();\r\n                lock.lockInterruptibly();\r\n                System.out.println(\"ReentrantLock is locked by  \"+Thread.currentThread().getName());\r\n            }catch (InterruptedException e){\r\n                System.out.println(Thread.currentThread().getName()+\" was interrupted while getting lock\");\r\n            }finally {\r\n                if(lock.isHeldByCurrentThread()) {\r\n                    System.out.println(\"ReentrantLock is released by  \"+Thread.currentThread().getName());\r\n                    lock.unlock();\r\n                }\r\n            }\r\n        });\r\n\r\n        Thread uninterruptibleThread = new Thread(()->{\r\n            System.out.println(\"ReentrantLock is locked by  \"+Thread.currentThread().getName());\r\n            try {\r\n                runnableWork();\r\n                lock.lock();\r\n            }catch (Exception e){\r\n                System.out.println(Thread.currentThread().getName()+\" was interrupted.\");\r\n            }finally {\r\n                System.out.println(\"ReentrantLock is released by  \"+Thread.currentThread().getName());\r\n                lock.unlock();\r\n            }\r\n        });\r\n\r\n        Thread interruptThread = new Thread(()->{\r\n            //uninterruptibleThread.interrupt();\r\n            interruptibleThread.interrupt();\r\n        });\r\n\r\n        interruptibleThread.start();\r\n//      uninterruptibleThread.start();\r\n        interruptThread.start();\r\n    }\r\n\r\n    public static void lock_tryLock_API(){\r\n        ReentrantLock lock = new ReentrantLock();\r\n        Thread t1 = new Thread(()->{\r\n            System.out.println(\"ReentrantLock is locked by  \"+Thread.currentThread().getName());\r\n            lock.lock();\r\n            try {\r\n                Thread.sleep(1000);\r\n            }catch (Exception e){}\r\n            System.out.println(\"ReentrantLock is released by  \"+Thread.currentThread().getName());\r\n            lock.unlock();\r\n        });\r\n\r\n        Thread t2 = new Thread(()->{\r\n            try {\r\n                System.out.println(\"Try to get the lock, if not, wait for sometime\");\r\n                boolean res = lock.tryLock(500l, TimeUnit.MILLISECONDS);//if timeout >1000, result will be true, because t1 released the lock after 1000ms\r\n                System.out.println(\"tryLock returns: \"+res+\" ,and \"+Thread.currentThread().getName()+\" is \"+Thread.currentThread().getState());\r\n            } catch (InterruptedException e) { }\r\n        });\r\n\r\n        t1.start();\r\n        t2.start();\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n        lock_tryLock_API();\r\n        lockInterruptibly_tryLock_API();\r\n    }\r\n}\r\n\r\n```\r\n\r\n>lockInterruptibly_tryLock_API\r\n\r\n尝试打断interruptibleThread，输出如下\r\n```java\r\n//output when interrupt interruptibleThread thread\r\n\r\nThread-0 was interrupted while getting lock\r\n```\r\n\r\n尝试打断uninterruptibleThread，输出如下\r\n```java\r\n//output when interrupt uninterruptibleThread thread\r\n\r\nReentrantLock is locked by  Thread-1\r\nReentrantLock is released by  Thread-1\r\n```\r\n>lock_tryLock_API\r\n\r\n调整tryLock的时间，可以观察到给定足够尝试时间的情况下才能获取到锁\r\n```java\r\n//output when tryLock time is NOT enough\r\n\r\nTry to get the lock, if not, wait for sometime\r\nReentrantLock is locked by  Thread-0\r\ntryLock returns: false ,and Thread-1 is RUNNABLE\r\nReentrantLock is released by  Thread-0\r\n\r\n//output when tryLock time is enough\r\nReentrantLock is locked by  Thread-0\r\nTry to get the lock, if not, wait for sometime\r\nReentrantLock is released by  Thread-0\r\ntryLock returns: true ,and Thread-1 is RUNNABLE\r\n\r\n```\r\n使用tryLock解决死锁问题\r\n\r\n一个典型的死锁案例，两个对象锁分别被两个线程持有，两个线程经过一段时间后各请求对方所持有的锁，自然就产生了死锁\r\n```\r\npublic class DeadLock {\r\n\r\n    public static final Object lock1 = new Object();\r\n    public static final Object lock2 = new Object();\r\n\r\n    public static void main(String[] a) {\r\n        Thread t1 = new Thread1();\r\n        Thread t2 = new Thread2();\r\n        t1.start();\r\n        t2.start();\r\n    }\r\n\r\n    private static class Thread1 extends Thread {\r\n\r\n        public void run() {\r\n            synchronized (lock1) {\r\n                try {\r\n                    Thread.sleep(10);\r\n                } catch (InterruptedException ignored) {}\r\n                synchronized (lock2) {\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private static class Thread2 extends Thread {\r\n\r\n        public void run() {\r\n            synchronized (lock2) {\r\n                try {\r\n                    Thread.sleep(10);\r\n                } catch (InterruptedException ignored) {}\r\n                synchronized (lock1) {\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n使用tryLock解决，我们的目的是使两个线程都能获取到两个锁，并且分别处理，那么我们可以把获取锁写在一个逻辑里\r\n```\r\npublic class DeadLock {\r\n\r\n    public static final ReentrantLock reentrantLock1 = new ReentrantLock();\r\n    public static final ReentrantLock reentrantLock2 = new ReentrantLock();\r\n\r\n    private static boolean getLocks(long milliseconds){\r\n        boolean getLock1 = false, getLock2 = false;\r\n        try{\r\n            getLock1 = reentrantLock1.tryLock(milliseconds, TimeUnit.MILLISECONDS);\r\n            getLock2 = reentrantLock2.tryLock(milliseconds,TimeUnit.MILLISECONDS);\r\n        }catch (Exception e){\r\n            e.printStackTrace();\r\n        } finally {\r\n            if(getLock1 && getLock2) return true;\r\n            else if(getLock1) reentrantLock1.unlock();\r\n            else if(getLock2) reentrantLock2.unlock();\r\n            return false;\r\n        }\r\n    }\r\n\r\n    public static void main(String[] a) {\r\n        Thread t1 = new Thread1();\r\n        Thread t2 = new Thread2();\r\n        t1.start();\r\n        t2.start();\r\n    }\r\n\r\n    private static class Thread1 extends Thread {\r\n        public void run() {\r\n            boolean res = getLocks(1000);\r\n            if(res){\r\n                System.out.println(Thread.currentThread().getName()+\" Got lock1?\"+reentrantLock1.isHeldByCurrentThread());\r\n                System.out.println(Thread.currentThread().getName()+\" Got lock2?\"+reentrantLock2.isHeldByCurrentThread());\r\n                try{\r\n                    //..do sth. with locked resources\r\n                    Thread.sleep(100);\r\n                }catch (Exception e){\r\n                   e.printStackTrace();\r\n                } finally {\r\n                    reentrantLock1.unlock();\r\n                    reentrantLock2.unlock();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private static class Thread2 extends Thread {\r\n        public void run() {\r\n            boolean res = getLocks(1000);\r\n            if(res){\r\n                System.out.println(Thread.currentThread().getName()+\" Got lock1?\"+reentrantLock1.isHeldByCurrentThread());\r\n                System.out.println(Thread.currentThread().getName()+\" Got lock2?\"+reentrantLock2.isHeldByCurrentThread());\r\n                try{\r\n                    //..do other things. with locked resources\r\n                    Thread.sleep(100);\r\n                }catch (Exception e){\r\n                    e.printStackTrace();\r\n                } finally {\r\n                    reentrantLock1.unlock();\r\n                    reentrantLock2.unlock();\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n我们模拟两个线程，可以看到输出中，两个线程分别获得了两个锁，从而解决了死锁的问题\r\n```\r\n//output\r\n\r\nThread-1 Got lock1?true\r\nThread-1 Got lock2?true\r\nThread-0 Got lock1?true\r\nThread-0 Got lock2?true\r\n```\r\n\r\n### Condition\r\nCondition对应一个ReentrantLock，在调用时，要求线程持有该ReentrantLock的锁，我们看下Condition类的实例方法：\r\n\r\n#### API\r\n方法名 | 参数 | 返回\r\n---|---|---\r\nawait||void\r\nawaitUninterruptibly||void\r\nawaitNanos|long|void\r\nawait|long,TimeUnit|boolean\r\nawaitUntil|Date|boolean\r\nsignal||void\r\nsignalAll||void\r\n可以看到，实际上主要实现了await和signal这两个功能，await和Object.await类似，给定等待时间，直到被通知，signal和notify类似，signal()唤醒等待在该Condition的线程，signalAll()唤醒所有等待在该Condition的线程\r\n\r\n#### ReentrantLock Condition Example\r\n两个方法分别对应两个示例\r\n\r\n第一个示例中，一个线程通过condition.signalAll唤醒另一个线程，相应的输出和使用方法与synchronized下的Object.notify，Object.await完全一致\r\n\r\n第二个示例中，前3个线程对应一个锁的ConditionA，后3个线程对应同一个锁的ConditionB，最后一个线程唤醒前3个线程，后3个线程在等待时间截止后自动执行，从而实现了线程的分组控制\r\n```java\r\npublic class ReentrantLockConditionAPI {\r\n    public static void singleConditionForThreads(){\r\n        ReentrantLock lock = new ReentrantLock();\r\n        Condition condition = lock.newCondition();\r\n        Thread t1 = new Thread(){\r\n            @Override\r\n            public void run() {\r\n                try {\r\n                    lock.lock();\r\n                    System.out.println(Thread.currentThread().getName()+\" work for 1 second\");\r\n                    Thread.sleep(1000);\r\n                    condition.await();//Must between lock() and unlock()\r\n                    System.out.println(\"Finished, start to wait\");\r\n                    System.out.println(Thread.currentThread().getName()+\" another work for 1 second\");\r\n                    Thread.sleep(1000);\r\n                }catch (Exception e){\r\n                    e.printStackTrace();\r\n                }finally {\r\n                    System.out.println(Thread.currentThread().getName() + \" finished\");\r\n                    lock.unlock();\r\n                }\r\n            }\r\n        };\r\n\r\n        Thread t2 = new Thread(){\r\n            @Override\r\n            public void run() {\r\n                try {\r\n                    Thread.sleep(100);\r\n                    lock.lock();\r\n                    System.out.println(Thread.currentThread().getName()+\" got the lock\");\r\n                    condition.signalAll();\r\n                }catch (Exception e){\r\n                    e.printStackTrace();\r\n                }finally {\r\n                    System.out.println(Thread.currentThread().getName()+\" finished\");\r\n                    lock.unlock();\r\n                }\r\n            }\r\n        };\r\n\r\n        t1.start();\r\n        t2.start();\r\n    }\r\n\r\n    public static void multipleConditionForThreadGroups(){\r\n        ReentrantLock lock = new ReentrantLock();\r\n        Condition conditionA = lock.newCondition();\r\n        Condition conditionB = lock.newCondition();\r\n\r\n        ExecutorService executorService = Executors.newFixedThreadPool(7);\r\n\r\n        //conditionA\r\n        for (int i = 0; i < 3; i++) {\r\n            executorService.submit(new Thread(){\r\n                @Override\r\n                public void run() {\r\n                    try {\r\n                        lock.lock();\r\n                        conditionA.await(2000,TimeUnit.MILLISECONDS);\r\n                        System.out.println(Thread.currentThread().getName()+\" got the lock again\");\r\n                    } catch (InterruptedException e) {\r\n                        e.printStackTrace();\r\n                    }finally {\r\n                        lock.unlock();\r\n                    }\r\n                }\r\n            });\r\n        }\r\n\r\n        //conditionB\r\n        for (int i = 0; i < 3; i++) {\r\n            executorService.submit(new Thread(){\r\n                @Override\r\n                public void run() {\r\n                    lock.lock();\r\n                    try {\r\n                        conditionB.await(2000, TimeUnit.MILLISECONDS);\r\n                        System.out.println(Thread.currentThread().getName()+\" got the lock again\");\r\n                    } catch (InterruptedException e) {\r\n                        e.printStackTrace();\r\n                    }finally {\r\n                        lock.unlock();\r\n                    }\r\n                }\r\n            });\r\n        }\r\n\r\n        executorService.submit(new Thread(){\r\n            @Override\r\n            public void run() {\r\n                try {\r\n                    Thread.sleep(1000);\r\n                    lock.lock();\r\n                    conditionA.signalAll();\r\n                    System.out.println(Thread.currentThread().getName()+\" signalAll conditionA threads\");\r\n                } catch (InterruptedException e) {\r\n                    e.printStackTrace();\r\n                }finally {\r\n                    lock.unlock();\r\n                }\r\n            }\r\n        });\r\n\r\n        executorService.shutdown();\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n        singleConditionForThreads();\r\n        multipleConditionForThreadGroups();\r\n    }\r\n}\r\n```\r\n\r\n第二个示例的输出（注意时间间隔）\r\n```java\r\n//output\r\npool-1-thread-7 signalAll conditionA threads\r\npool-1-thread-1 got the lock again\r\npool-1-thread-2 got the lock again\r\npool-1-thread-3 got the lock again\r\npool-1-thread-4 got the lock again\r\npool-1-thread-5 got the lock again\r\npool-1-thread-6 got the lock again\r\n```\r\n### Semaphore\r\nSemaphore提供了信号量机制，作为mutex（互斥量）与ReentrantLock类似，不同的是，ReentrantLock中的Condition要求线程必须持有锁，并且一个锁只能被一个线程持有，而Semaphore允许多线程访问同一资源。当Semaphore不允许访问资源时，线程会被阻塞直到可以获取permit\r\n\r\n### API\r\n方法 | 解释\r\n---|---\r\nSemaphore(int permits, boolean fair) | 构造方法，两个参数分别表示permit数量，是否公平锁，默认非公平锁\r\nacquire()|获取permit，否则阻塞直到可以获取\r\nrelease()|释放permit，注意这里可以超过构造方法中允许的permit数量，也就是可以不用acquire直接release\r\navailablePermits()|查看目前可用的permit\r\ndrainPermits()|把permit置0，返回所有permit的数量\r\n\r\n#### 与其他锁机制的对比\r\nSemaphore不关心获取锁和释放锁的对象，并且允许多线程同时访问同一资源，acquire和release只是发放和收回permit（许可），是一种相对高级的同步机制\r\n\r\n#### Semaphore Example\r\n因为是高级API，所以没啥特别的，示例中一个容量为5的信号量跑20个线程，可以防止死锁，互斥执行\r\n```java\r\npublic class SemaphoreAPI {\r\n    public static void main(String[] args) {\r\n        Semaphore semaphore = new Semaphore(5);\r\n        ExecutorService executorService = Executors.newFixedThreadPool(20);\r\n        for (int i = 0; i < 20; i++) {\r\n            executorService.submit(()->{\r\n                try {\r\n                    semaphore.acquire();\r\n                    System.out.println(Thread.currentThread().getName()+\" is doing some work\");\r\n                    Thread.sleep(1000);\r\n                } catch (InterruptedException e) {\r\n                    e.printStackTrace();\r\n                }finally {\r\n                    semaphore.release();\r\n                }\r\n            });\r\n        }\r\n        executorService.shutdown();\r\n    }\r\n}\r\n```\r\n\r\n### refs\r\nhttps://juejin.im/post/5ce91cedf265da1bca51b78a\r\nhttps://stackoverflow.com/questions/17683575/binary-semaphore-vs-a-reentrantlock\r\nhttps://www.geeksforgeeks.org/reentrant-lock-java/","frontmatter":{"abstract":"Java 多线程工具类 简介，包括 notify wait, CountDownLatch, ReentranceLock 等方法的功能和模拟","draft":null,"title":"Java Multi Thread Utils","tags":["中文","Java","multi thread","java util","jdk"],"cover":"https://unsplash.it/1152/300/?random?SuperLong","date":"2019/07/07"}}}]}},"pageContext":{"tag":"java util"}},"staticQueryHashes":[]}