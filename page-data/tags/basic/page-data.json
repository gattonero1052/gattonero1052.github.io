{"componentChunkName":"component---src-templates-tag-jsx","path":"/tags/basic/","result":{"data":{"allMarkdownRemark":{"totalCount":1,"edges":[{"node":{"fields":{"slug":"/Java/java-multi-thread-basic","date":"2019-07-07T04:00:00.000Z"},"excerpt":"JMM（Java内存模型） Java内存模型是一种逻辑模型，是一组预定规范，定义了每个变量的访问方式，简要运行方式如下 Java内存区域，描述了Java内存的物理分布 Java内存区域 JMM分为主内存和工作内存（栈空间），JVM会为每一个线程分配一个工作内存，Java…","timeToRead":5,"rawMarkdownBody":"### JMM（Java内存模型）\r\n- Java内存模型是一种逻辑模型，是一组预定规范，定义了每个变量的访问方式，简要运行方式如下\r\n- Java内存区域，描述了Java内存的物理分布\r\n>![Java内存区域](https://upload-images.jianshu.io/upload_images/4655525-b77986e96850367e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\r\n\r\n>JMM分为主内存和工作内存（栈空间），JVM会为每一个线程分配一个工作内存，Java中所有的实例对象都存在主存中，主存对所有线程共享，但线程不能直接操作主存，只能先进行拷贝，操作完毕后再存进主存中。工作内存是私有的，存有主存数据的副本，线程间的通信必须通过主存来进行\r\n\r\n### JMM的数据存储\r\n方法中的基本数据类型存储在工作内存的栈帧中，对象实例的引用也存储在栈帧中，但值存在主存中，除此之外，例如成员变量，静态变量等都存在主存中\r\n\r\n### JMM保证线程安全的三个特性\r\n- 原子性：指不可中断的操作，理论上对于32位操作系统来说，long和double数据的读取是非原子操作\r\n\r\n- 可见性：一个线程间共享的变量可见，指当一个线程修改了该共享变量的值，其他线程是否能立刻获取到这一次的修改。对于单线程来说，这个问题是不存在的，而对于多线程来说，如果存在工作内存和主存的同步延迟，就会出现一个线程修改变量之后，另一个线程仍然读取修改前主存中的变量值\r\n\r\n- 有序性：对于多线程，编译成机器码后会出现指令重排的现象，对于一个线程来说，每条指令的执行顺序是固定的，但对于多个线程来说，指令的执行顺序是不固定的\r\n### JMM提供的线程安全解决方案\r\n- 对数据的原子性操作，可以使用java.util.concurrent.atomic.*这个包，对代码块的原子性操作，可以使用synchronized关键字或者重入锁(ReentrantLock)\r\n\r\n- happens-before原则\r\n>一套辅助规则保证程序执行的原子性，可见性和有序性\r\n- 同一线程中，代码一定按顺序执行\r\n- 同一个锁，先进行解锁才能加锁（也就是说加锁和解锁一定是轮流执行）\r\n- 对于volatile变量，强制从主存中读取，并且在改变后强制刷新到主存\r\n- 线程启动规则：线程的start()方法先于它的每一个动作\r\n- 线程终止规则：线程的终止在所有动作之后（例如线程A中执行了线程B.join()，那么B中所有的对共享变量的操作结果，都能在B.join()结束后被A读取到）\r\n- 线程中断规则：interrupt()方法先执行，Thread.interrupted()再返回true\r\n- 对象终结规则：对象的构造函数先于finalize()方法（但一般不会Override finalize()方法）\r\n\r\n### 新建线程的三种方式\r\n\r\n- 继承Thread类\r\n- 实现Runnable接口（lambda，匿名内部类等）\r\n- 实现Callable接口\r\n\r\n### 线程状态\r\n\r\n名称 | 状态\r\n---|---\r\nNEW | 构建完毕，但是没有start()\r\nRUNNABLE | 运行中，包括就绪和运行状态\r\nBLOCKED | 线程阻塞，被锁住\r\nWAITING | 线程进入等待状态，需要其他线程通知或中断\r\nTIME_WAITING | 超时等待，可以在指定时间自行改变\r\nTERMINATED | 线程终止，已执行完毕\r\n\r\n### 线程操作\r\n- interrupt 不改变线程的状态情况下实现线程间的交互，可以用于线程结束时清理资源\r\n- join 将另一个线程加入当前线程，同步执行\r\n- sleep 让线程按指定时间休眠，注意和Object.wait()的比较\r\n- yield 让当前线程让出cpu，注意与sleep比较\r\n\r\n#### interrupt机制\r\n当调用thread.interrupt()时\r\n1. 线程在sleep, wait, join, 方法会被唤醒，并且需要对interruptedException进行处理\r\n2. 线程运行（RUNNABLE）中，会设置interrupt标志位，可通过isInterrupted()进行查看并进行处理\r\n\r\n### 守护线程\r\n例如GC，JIT线程就属于守护线程，可以通过setDaemon设置，当虚拟机只有守护线程时，线程会执行退出\r\n\r\n### Tips\r\n- yield VS sleep \r\n1. yield只是使当前线程让出cpu，不一定会切换到其他线程\r\n2. yield让出cpu后，只有与当前线程具有相同优先级的线程有竞争权，而sleep交出的时间片，其他线程都可以竞争\r\n- 编译器重排和处理器指令重排：\r\n1. 简单地说，比如线程A有指令A1,A2,A3，线程B有指令B1,B2,B3，A1A2A3B1B2B3，A1B1B2B3A2A3等等都是可能出现的指令顺序\r\n2. 赋值语句的重排属于编译器重排，而机器码指令的重排数据处理器重排\r\n### ref\r\nhttps://www.jianshu.com/p/f65ea68a4a7f\r\nhttps://blog.csdn.net/javazejian/article/details/72772461\r\nhttps://blog.csdn.net/javazejian/article/details/72828483","frontmatter":{"abstract":"","draft":null,"title":"Java Multi Thread Basic","tags":["中文","Java","multi thread","basic"],"cover":"","date":"2019/7/7"}}}]}},"pageContext":{"tag":"basic"}},"staticQueryHashes":[]}