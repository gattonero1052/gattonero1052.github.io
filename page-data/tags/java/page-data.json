{"componentChunkName":"component---src-templates-tag-jsx","path":"/tags/java/","result":{"data":{"allMarkdownRemark":{"totalCount":3,"edges":[{"node":{"fields":{"slug":"/Java/java-multi-thread-synchronize","date":"2019-10-04T04:00:00.000Z"},"excerpt":"…","timeToRead":3,"rawMarkdownBody":"\r\n### 线程安全相关问题\r\n\r\n- 如何定义一个对象是否是线程安全的\r\n> 当多个线程访问同一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替运行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获取正确的结果，那这个对象是线程安全的\r\n\r\n- 线程安全问题的主要原因是\r\n>主内存和工作内存数据不一致，重排序（为了性能优化，一般包括编译器指令重排序和处理器指令重排序）导致竞态条件下的程序执行不确定性\r\n\r\n### synchronized\r\n- synchronized的应用方式主要有修饰实例方法，修饰静态方法，修饰代码块\r\n- 修饰实例方法\r\n\r\n>对实例方法的修饰，同步锁加在当前实例对象上，当一个线程访问改实例的synchronized方法时，其他线程不能访问该方法\r\n\r\n>同步锁和实例对象一一对应，如果是一个线程 A 需要访问实例对象 obj1 的 synchronized 方法 f1(当前对象锁是obj1)，另一个线程 B 需要访问实例对象 obj2 的 synchronized 方法 f2(当前对象锁是obj2)，是可以同时访问同一个方法的，因为两个实例对象锁并不同相同\r\n\r\n- 修饰静态方法\r\n>对静态方法的修饰，同步锁加在当前类的class对象上（并非实例对象），所以不同的线程可以同时访问同一实例的同步静态方法和同步实例方法\r\n\r\n- 修饰代码块\r\n>实例对象锁：synchronized(this){...}\r\n>class对象锁：synchronized(XXX.class){...}\r\n\r\n- synchronized的可重入性\r\n在一个线程调用synchronized方法的同时在其方法体内部调用该对象另一个synchronized方法，也就是说一个线程得到一个对象锁后再次请求该对象锁，是允许的，这就是synchronized的可重入性\r\n\r\n- synchronized与等待唤醒机制（wait, notify）\r\n>调用等待唤醒机制相关方法时，必须获得当前对象的monitor对象，而只有synchronized关键字才能获取到monitor对象，所以只有在同步方法块中才能调用wait, notify方法\r\n```java\r\nsynchronized (obj) {\r\n       obj.wait();\r\n       obj.notify();\r\n       obj.notifyAll();         \r\n }\r\n```\r\n>wait和sleep的对比：sleep方法并不会让当前线程释放锁，但是wait会命令当前线程在执行完同步代码段后释放持有的锁\r\n\r\n- Java对象在内存中的布局\r\n\r\n名称 | 内容\r\n---|---\r\n对象头 | 具体如下\r\n实例变量 | 实例所属类的属性，数组长度等信息\r\n填充数据 | 保持字节对齐而填充的数据（因对象的起始地址必须是8字节整数倍）\r\n\r\n- Java对象头\r\n> JVM使用2个字节来存储该信息，如果是数组对象，会有1个额外的字节存储数组长度\r\n\r\n名称 | 内容\r\n---|---\r\nMark Word | 存储对象的hashCode、锁信息或分代年龄或GC标志等信息\r\nClass Metadata Address | 类型指针指向对象的类元数据，JVM通过这个指针确定该对象是哪个类的实例\r\n\r\n### Tips\r\n- 线程随机竞争同一资源时，如果对访问顺序敏感，那么此时存在静态条件\r\n- \r\n### ref\r\nhttps://www.jianshu.com/p/d52fea0d6ba5\r\n","frontmatter":{"abstract":"","draft":null,"title":"Java Multi Thread Synchronize","tags":["中文","Java","multi thread","synchronize"],"cover":"","date":"2019/10/4"}}},{"node":{"fields":{"slug":"/Java/java-multi-thread-basic","date":"2019-07-07T04:00:00.000Z"},"excerpt":"JMM（Java内存模型） Java内存模型是一种逻辑模型，是一组预定规范，定义了每个变量的访问方式，简要运行方式如下 Java内存区域，描述了Java内存的物理分布 Java内存区域 JMM分为主内存和工作内存（栈空间），JVM会为每一个线程分配一个工作内存，Java…","timeToRead":5,"rawMarkdownBody":"### JMM（Java内存模型）\r\n- Java内存模型是一种逻辑模型，是一组预定规范，定义了每个变量的访问方式，简要运行方式如下\r\n- Java内存区域，描述了Java内存的物理分布\r\n>![Java内存区域](https://upload-images.jianshu.io/upload_images/4655525-b77986e96850367e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\r\n\r\n>JMM分为主内存和工作内存（栈空间），JVM会为每一个线程分配一个工作内存，Java中所有的实例对象都存在主存中，主存对所有线程共享，但线程不能直接操作主存，只能先进行拷贝，操作完毕后再存进主存中。工作内存是私有的，存有主存数据的副本，线程间的通信必须通过主存来进行\r\n\r\n### JMM的数据存储\r\n方法中的基本数据类型存储在工作内存的栈帧中，对象实例的引用也存储在栈帧中，但值存在主存中，除此之外，例如成员变量，静态变量等都存在主存中\r\n\r\n### JMM保证线程安全的三个特性\r\n- 原子性：指不可中断的操作，理论上对于32位操作系统来说，long和double数据的读取是非原子操作\r\n\r\n- 可见性：一个线程间共享的变量可见，指当一个线程修改了该共享变量的值，其他线程是否能立刻获取到这一次的修改。对于单线程来说，这个问题是不存在的，而对于多线程来说，如果存在工作内存和主存的同步延迟，就会出现一个线程修改变量之后，另一个线程仍然读取修改前主存中的变量值\r\n\r\n- 有序性：对于多线程，编译成机器码后会出现指令重排的现象，对于一个线程来说，每条指令的执行顺序是固定的，但对于多个线程来说，指令的执行顺序是不固定的\r\n### JMM提供的线程安全解决方案\r\n- 对数据的原子性操作，可以使用java.util.concurrent.atomic.*这个包，对代码块的原子性操作，可以使用synchronized关键字或者重入锁(ReentrantLock)\r\n\r\n- happens-before原则\r\n>一套辅助规则保证程序执行的原子性，可见性和有序性\r\n- 同一线程中，代码一定按顺序执行\r\n- 同一个锁，先进行解锁才能加锁（也就是说加锁和解锁一定是轮流执行）\r\n- 对于volatile变量，强制从主存中读取，并且在改变后强制刷新到主存\r\n- 线程启动规则：线程的start()方法先于它的每一个动作\r\n- 线程终止规则：线程的终止在所有动作之后（例如线程A中执行了线程B.join()，那么B中所有的对共享变量的操作结果，都能在B.join()结束后被A读取到）\r\n- 线程中断规则：interrupt()方法先执行，Thread.interrupted()再返回true\r\n- 对象终结规则：对象的构造函数先于finalize()方法（但一般不会Override finalize()方法）\r\n\r\n### 新建线程的三种方式\r\n\r\n- 继承Thread类\r\n- 实现Runnable接口（lambda，匿名内部类等）\r\n- 实现Callable接口\r\n\r\n### 线程状态\r\n\r\n名称 | 状态\r\n---|---\r\nNEW | 构建完毕，但是没有start()\r\nRUNNABLE | 运行中，包括就绪和运行状态\r\nBLOCKED | 线程阻塞，被锁住\r\nWAITING | 线程进入等待状态，需要其他线程通知或中断\r\nTIME_WAITING | 超时等待，可以在指定时间自行改变\r\nTERMINATED | 线程终止，已执行完毕\r\n\r\n### 线程操作\r\n- interrupt 不改变线程的状态情况下实现线程间的交互，可以用于线程结束时清理资源\r\n- join 将另一个线程加入当前线程，同步执行\r\n- sleep 让线程按指定时间休眠，注意和Object.wait()的比较\r\n- yield 让当前线程让出cpu，注意与sleep比较\r\n\r\n#### interrupt机制\r\n当调用thread.interrupt()时\r\n1. 线程在sleep, wait, join, 方法会被唤醒，并且需要对interruptedException进行处理\r\n2. 线程运行（RUNNABLE）中，会设置interrupt标志位，可通过isInterrupted()进行查看并进行处理\r\n\r\n### 守护线程\r\n例如GC，JIT线程就属于守护线程，可以通过setDaemon设置，当虚拟机只有守护线程时，线程会执行退出\r\n\r\n### Tips\r\n- yield VS sleep \r\n1. yield只是使当前线程让出cpu，不一定会切换到其他线程\r\n2. yield让出cpu后，只有与当前线程具有相同优先级的线程有竞争权，而sleep交出的时间片，其他线程都可以竞争\r\n- 编译器重排和处理器指令重排：\r\n1. 简单地说，比如线程A有指令A1,A2,A3，线程B有指令B1,B2,B3，A1A2A3B1B2B3，A1B1B2B3A2A3等等都是可能出现的指令顺序\r\n2. 赋值语句的重排属于编译器重排，而机器码指令的重排数据处理器重排\r\n### ref\r\nhttps://www.jianshu.com/p/f65ea68a4a7f\r\nhttps://blog.csdn.net/javazejian/article/details/72772461\r\nhttps://blog.csdn.net/javazejian/article/details/72828483","frontmatter":{"abstract":"","draft":null,"title":"Java Multi Thread Basic","tags":["中文","Java","multi thread","basic"],"cover":"","date":"2019/7/7"}}},{"node":{"fields":{"slug":"/Java/java-multi-thread-utils","date":"2019-07-07T04:00:00.000Z"},"excerpt":"notify wait wait()、notify()和notifyAll()是Object类中的native final方法（除重载），这两个方法是为了解决多线程环境下的竞态环境，必须在同步方法块内调用 notify,notifyAll…","timeToRead":13,"rawMarkdownBody":"### notify wait\r\nwait()、notify()和notifyAll()是Object类中的native final方法（除重载），这两个方法是为了解决多线程环境下的竞态环境，必须在同步方法块内调用\r\n\r\n- notify,notifyAll 唤起其他等待锁的线程，但并不会立刻切换到其他线程，而是等到执行完同步代码块之后再进行切换，使用notify会唤起最先等待的线程，notifyAll会唤起所有等待的线程\r\n\r\n- wait 使当前线程阻塞，释放所持有的锁（不必等到同步代码块结束）\r\n\r\n- 不建议直接使用notify wait进行多线程编程\r\n\r\n模拟使用notify的场景：两个线程竞争同一资源\r\n```java\r\n\r\n//two threads competing for one resource\r\npublic class CompetingThread {\r\n    Thread[] threads;\r\n\r\n    CompetingThread(Thread[] threads){\r\n        this.threads= threads;\r\n    }\r\n\r\n    public void get() {\r\n        Thread t1 = threads[0], t2 = threads[1];\r\n        System.out.println(\"Ready to Get\");\r\n        synchronized (this){\r\n            System.out.println(Thread.currentThread().getName()+\" Got the lock\");\r\n\r\n            System.out.println(\"Now, \"+t1.getName()+\" is \"+t1.getState()+\", \"+t2.getName()+\" is \"+t2.getState());\r\n            System.out.println(\"notify() to release the lock after all done\");\r\n            System.out.println(\"Do sth. before notify is just the same as after\");\r\n            notify();\r\n            System.out.println(\"Do sth. after notify is just the same as before\");\r\n            System.out.println(Thread.currentThread().getName()+\" is done.\");\r\n        }\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n        Thread[] threads = new Thread[2];\r\n        CompetingThread competingThread = new CompetingThread(threads);\r\n        threads[0] = new Thread(()->competingThread.get());\r\n        threads[1] = new Thread(()->competingThread.get());\r\n        threads[0].start();\r\n        threads[1].start();\r\n    }\r\n}\r\n\r\n```\r\n\r\n输出\r\n\r\n```text\r\n//output\r\n\r\nReady to Get\r\nReady to Get\r\nThread-0 Got the lock\r\nNow, Thread-0 is RUNNABLE, Thread-1 is BLOCKED\r\nnotify() to release the lock after all done\r\nDo sth. before notify is just the same as after\r\nDo sth. after notify is just the same as before\r\nThread-0 is done.\r\nThread-1 Got the lock\r\nNow, Thread-0 is TERMINATED, Thread-1 is RUNNABLE\r\nnotify() to release the lock after all done\r\nDo sth. before notify is just the same as after\r\nDo sth. after notify is just the same as before\r\nThread-1 is done.\r\n```\r\n模拟使用wait和notify(notifyAll)的场景：顾客在餐厅点餐，服务员等候（BLOCKING），点餐完毕，顾客等候上菜（wait()），服务员上菜，告知顾客菜来了（notify()）\r\n```java\r\npublic class WaitNotifyExample {\r\n    public static Object menu = new Object();\r\n\r\n    public static void main(String[] args) {\r\n        Thread customer = new Thread() {\r\n            @Override\r\n            public void run() {\r\n                synchronized (menu) {\r\n                    System.out.println(\"Customer: I'm reading menu, please wait\");\r\n                    try {\r\n                        Thread.sleep(1000);\r\n                        System.out.println(\"Customer: These are my orders.(waiting for the meal)\");\r\n                        menu.wait();\r\n                    }catch (InterruptedException e){}\r\n                    System.out.println(\"Customer: Oh, these are my foods!\");\r\n                }\r\n            }\r\n        };\r\n\r\n        Thread waiter = new Thread(){\r\n            @Override\r\n            public void run(){\r\n                System.out.println(\"Waiter: (Waiting for customer's orders)\");\r\n                synchronized (menu){\r\n                    System.out.println(\"Waiter: Gonna prepare you meal, sir.\");\r\n                    try {\r\n                        Thread.sleep(1000);\r\n                        menu.notify();//notifyAll if there are more than 1 customer\r\n                        System.out.println(\"Waiter: Your foods are ready.\");\r\n                    }catch (InterruptedException e){}\r\n                }\r\n            }\r\n        };\r\n\r\n        customer.start();\r\n        waiter.start();\r\n    }\r\n}\r\n```\r\n输出\r\n```text\r\n//output\r\n\r\nCustomer: I'm reading menu, please wait\r\nWaiter: (Waiting for customer's orders)\r\nCustomer: These are my orders.(waiting for the meal)\r\nWaiter: Gonna prepare you meal, sir.\r\nWaiter: Your foods are ready.\r\nCustomer: Oh, these are my foods!\r\n\r\n```\r\n\r\n### CountDownLatch\r\n一个线程安全的倒计时器，在倒计时为0前，令线程等待（getState()：WAITING）\r\n\r\n使用步骤：\r\n- 构造一个容量为10的倒计时器 `CountDownLatch latch = new CountDownLatch(10)`\r\n- 主线程中调用`latch.await()`，等待相关线程进行倒计时\r\n- 不同的线程中调用该倒计时器实例的`latch.countDown()`方法，进行倒计时\r\n- 当latch的倒计时为0时，主线程恢复运行\r\n\r\n### ReentrantLock\r\nReentrantLock(Re-entrantLock)是一个基于AQS（AbstractQueuedSynchronizer）高性能工具，支持线程在未释放锁的情况下重复获取锁\r\n#### API\r\n方法 | 解释\r\n---|---\r\nlock | holdCount+1，并给当前线程加锁\r\nunlock | holdCount-1，holdCount为0时，释放资源\r\ntryLock | 如果资源锁不在其他线程中，返回true，holdCount+1，否则返回false，不过线程并不会阻塞\r\nlockInterruptibly() | 锁空闲的情况下正常获取，但是允许被其他线程的请求中断\r\ngetHoldCount | 获取holdCount，注意如果持有锁的不是本线程，则直接返回0\r\n\r\n#### 原理概述\r\nReentrantLock的可重入功能基于AQS的同步状态：state（可通过getHoldCount获取）。当某一线程获取锁后，holdCount+1，并记录下当前持有锁的线程，再有线程来获取锁时，判断这个线程与持有锁的线程是否是同一个线程，如果是，holdCount+1，如果不是，阻塞线程。\r\n当线程释放锁时，holdCount-1，holdCount为0时，唤醒其他线程，使其重新竞争锁。\r\n\r\n#### 解决问题\r\n\r\n- 解决synchronized在竞争激烈场景下的性能问题\r\n>在锁竞争不激烈的时候，多数情况下锁会停留在偏向锁和轻量级锁阶段,这两个阶段下，synchronized性能很好，但当存在大量线程竞争锁时，可能会膨胀为重量级锁，性能下降，ReentrantLock的性能会优于synchronized。不过在JDK1.6之后，synchronized进行了优化，大多数场景下性能与ReentrantLock所差无几\r\n\r\n- 填补其他synchronized的缺陷\r\n>一旦线程卡在等待锁的阶段，就有可能出现死锁\r\n\r\n>不可响应中断\r\n\r\n>不能尝试获取锁\r\n\r\n#### ReentrantLock VS synchronized\r\n>对多线程操作支持情况和实现方式（如果支持的话）\r\n\r\n项目\\锁 | synchronized | \tReentrantLock\r\n---|---|---\r\n公平性|只支持非公平锁 | 支持公平锁和非公平锁\r\n是否支持尝试获取锁|不支持|支持 tryLock(time, TimeUnit)\r\n是否可响应中断|不支持|支持 lockInterruptibly\r\n等待条件|支持 notify wait | 支持 Condition\r\n\r\n\r\n#### ReentrantLock Example\r\ntryLock，lock，lockInterruptibly的对比测试，runnableWork是一个耗时操作，目的是让线程状态保持在RUNNABLE\r\n```java\r\npublic class ReentrantLockAPI {\r\n    public static void runnableWork(){\r\n        for (int i = 0; i < 1000; i++) {\r\n            for (int j = 0; j < 1000; j++) {\r\n                for (int k = 0; k < 1000; k++) {\r\n\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    public static void lockInterruptibly_tryLock_API(){\r\n        final ReentrantLock lock = new ReentrantLock();\r\n        Thread interruptibleThread = new Thread(()->{\r\n            try {\r\n                runnableWork();\r\n                lock.lockInterruptibly();\r\n                System.out.println(\"ReentrantLock is locked by  \"+Thread.currentThread().getName());\r\n            }catch (InterruptedException e){\r\n                System.out.println(Thread.currentThread().getName()+\" was interrupted while getting lock\");\r\n            }finally {\r\n                if(lock.isHeldByCurrentThread()) {\r\n                    System.out.println(\"ReentrantLock is released by  \"+Thread.currentThread().getName());\r\n                    lock.unlock();\r\n                }\r\n            }\r\n        });\r\n\r\n        Thread uninterruptibleThread = new Thread(()->{\r\n            System.out.println(\"ReentrantLock is locked by  \"+Thread.currentThread().getName());\r\n            try {\r\n                runnableWork();\r\n                lock.lock();\r\n            }catch (Exception e){\r\n                System.out.println(Thread.currentThread().getName()+\" was interrupted.\");\r\n            }finally {\r\n                System.out.println(\"ReentrantLock is released by  \"+Thread.currentThread().getName());\r\n                lock.unlock();\r\n            }\r\n        });\r\n\r\n        Thread interruptThread = new Thread(()->{\r\n            //uninterruptibleThread.interrupt();\r\n            interruptibleThread.interrupt();\r\n        });\r\n\r\n        interruptibleThread.start();\r\n//      uninterruptibleThread.start();\r\n        interruptThread.start();\r\n    }\r\n\r\n    public static void lock_tryLock_API(){\r\n        ReentrantLock lock = new ReentrantLock();\r\n        Thread t1 = new Thread(()->{\r\n            System.out.println(\"ReentrantLock is locked by  \"+Thread.currentThread().getName());\r\n            lock.lock();\r\n            try {\r\n                Thread.sleep(1000);\r\n            }catch (Exception e){}\r\n            System.out.println(\"ReentrantLock is released by  \"+Thread.currentThread().getName());\r\n            lock.unlock();\r\n        });\r\n\r\n        Thread t2 = new Thread(()->{\r\n            try {\r\n                System.out.println(\"Try to get the lock, if not, wait for sometime\");\r\n                boolean res = lock.tryLock(500l, TimeUnit.MILLISECONDS);//if timeout >1000, result will be true, because t1 released the lock after 1000ms\r\n                System.out.println(\"tryLock returns: \"+res+\" ,and \"+Thread.currentThread().getName()+\" is \"+Thread.currentThread().getState());\r\n            } catch (InterruptedException e) { }\r\n        });\r\n\r\n        t1.start();\r\n        t2.start();\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n        lock_tryLock_API();\r\n        lockInterruptibly_tryLock_API();\r\n    }\r\n}\r\n\r\n```\r\n\r\n>lockInterruptibly_tryLock_API\r\n\r\n尝试打断interruptibleThread，输出如下\r\n```java\r\n//output when interrupt interruptibleThread thread\r\n\r\nThread-0 was interrupted while getting lock\r\n```\r\n\r\n尝试打断uninterruptibleThread，输出如下\r\n```java\r\n//output when interrupt uninterruptibleThread thread\r\n\r\nReentrantLock is locked by  Thread-1\r\nReentrantLock is released by  Thread-1\r\n```\r\n>lock_tryLock_API\r\n\r\n调整tryLock的时间，可以观察到给定足够尝试时间的情况下才能获取到锁\r\n```java\r\n//output when tryLock time is NOT enough\r\n\r\nTry to get the lock, if not, wait for sometime\r\nReentrantLock is locked by  Thread-0\r\ntryLock returns: false ,and Thread-1 is RUNNABLE\r\nReentrantLock is released by  Thread-0\r\n\r\n//output when tryLock time is enough\r\nReentrantLock is locked by  Thread-0\r\nTry to get the lock, if not, wait for sometime\r\nReentrantLock is released by  Thread-0\r\ntryLock returns: true ,and Thread-1 is RUNNABLE\r\n\r\n```\r\n使用tryLock解决死锁问题\r\n\r\n一个典型的死锁案例，两个对象锁分别被两个线程持有，两个线程经过一段时间后各请求对方所持有的锁，自然就产生了死锁\r\n```\r\npublic class DeadLock {\r\n\r\n    public static final Object lock1 = new Object();\r\n    public static final Object lock2 = new Object();\r\n\r\n    public static void main(String[] a) {\r\n        Thread t1 = new Thread1();\r\n        Thread t2 = new Thread2();\r\n        t1.start();\r\n        t2.start();\r\n    }\r\n\r\n    private static class Thread1 extends Thread {\r\n\r\n        public void run() {\r\n            synchronized (lock1) {\r\n                try {\r\n                    Thread.sleep(10);\r\n                } catch (InterruptedException ignored) {}\r\n                synchronized (lock2) {\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private static class Thread2 extends Thread {\r\n\r\n        public void run() {\r\n            synchronized (lock2) {\r\n                try {\r\n                    Thread.sleep(10);\r\n                } catch (InterruptedException ignored) {}\r\n                synchronized (lock1) {\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n使用tryLock解决，我们的目的是使两个线程都能获取到两个锁，并且分别处理，那么我们可以把获取锁写在一个逻辑里\r\n```\r\npublic class DeadLock {\r\n\r\n    public static final ReentrantLock reentrantLock1 = new ReentrantLock();\r\n    public static final ReentrantLock reentrantLock2 = new ReentrantLock();\r\n\r\n    private static boolean getLocks(long milliseconds){\r\n        boolean getLock1 = false, getLock2 = false;\r\n        try{\r\n            getLock1 = reentrantLock1.tryLock(milliseconds, TimeUnit.MILLISECONDS);\r\n            getLock2 = reentrantLock2.tryLock(milliseconds,TimeUnit.MILLISECONDS);\r\n        }catch (Exception e){\r\n            e.printStackTrace();\r\n        } finally {\r\n            if(getLock1 && getLock2) return true;\r\n            else if(getLock1) reentrantLock1.unlock();\r\n            else if(getLock2) reentrantLock2.unlock();\r\n            return false;\r\n        }\r\n    }\r\n\r\n    public static void main(String[] a) {\r\n        Thread t1 = new Thread1();\r\n        Thread t2 = new Thread2();\r\n        t1.start();\r\n        t2.start();\r\n    }\r\n\r\n    private static class Thread1 extends Thread {\r\n        public void run() {\r\n            boolean res = getLocks(1000);\r\n            if(res){\r\n                System.out.println(Thread.currentThread().getName()+\" Got lock1?\"+reentrantLock1.isHeldByCurrentThread());\r\n                System.out.println(Thread.currentThread().getName()+\" Got lock2?\"+reentrantLock2.isHeldByCurrentThread());\r\n                try{\r\n                    //..do sth. with locked resources\r\n                    Thread.sleep(100);\r\n                }catch (Exception e){\r\n                   e.printStackTrace();\r\n                } finally {\r\n                    reentrantLock1.unlock();\r\n                    reentrantLock2.unlock();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private static class Thread2 extends Thread {\r\n        public void run() {\r\n            boolean res = getLocks(1000);\r\n            if(res){\r\n                System.out.println(Thread.currentThread().getName()+\" Got lock1?\"+reentrantLock1.isHeldByCurrentThread());\r\n                System.out.println(Thread.currentThread().getName()+\" Got lock2?\"+reentrantLock2.isHeldByCurrentThread());\r\n                try{\r\n                    //..do other things. with locked resources\r\n                    Thread.sleep(100);\r\n                }catch (Exception e){\r\n                    e.printStackTrace();\r\n                } finally {\r\n                    reentrantLock1.unlock();\r\n                    reentrantLock2.unlock();\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n我们模拟两个线程，可以看到输出中，两个线程分别获得了两个锁，从而解决了死锁的问题\r\n```\r\n//output\r\n\r\nThread-1 Got lock1?true\r\nThread-1 Got lock2?true\r\nThread-0 Got lock1?true\r\nThread-0 Got lock2?true\r\n```\r\n\r\n### Condition\r\nCondition对应一个ReentrantLock，在调用时，要求线程持有该ReentrantLock的锁，我们看下Condition类的实例方法：\r\n\r\n#### API\r\n方法名 | 参数 | 返回\r\n---|---|---\r\nawait||void\r\nawaitUninterruptibly||void\r\nawaitNanos|long|void\r\nawait|long,TimeUnit|boolean\r\nawaitUntil|Date|boolean\r\nsignal||void\r\nsignalAll||void\r\n可以看到，实际上主要实现了await和signal这两个功能，await和Object.await类似，给定等待时间，直到被通知，signal和notify类似，signal()唤醒等待在该Condition的线程，signalAll()唤醒所有等待在该Condition的线程\r\n\r\n#### ReentrantLock Condition Example\r\n两个方法分别对应两个示例\r\n\r\n第一个示例中，一个线程通过condition.signalAll唤醒另一个线程，相应的输出和使用方法与synchronized下的Object.notify，Object.await完全一致\r\n\r\n第二个示例中，前3个线程对应一个锁的ConditionA，后3个线程对应同一个锁的ConditionB，最后一个线程唤醒前3个线程，后3个线程在等待时间截止后自动执行，从而实现了线程的分组控制\r\n```java\r\npublic class ReentrantLockConditionAPI {\r\n    public static void singleConditionForThreads(){\r\n        ReentrantLock lock = new ReentrantLock();\r\n        Condition condition = lock.newCondition();\r\n        Thread t1 = new Thread(){\r\n            @Override\r\n            public void run() {\r\n                try {\r\n                    lock.lock();\r\n                    System.out.println(Thread.currentThread().getName()+\" work for 1 second\");\r\n                    Thread.sleep(1000);\r\n                    condition.await();//Must between lock() and unlock()\r\n                    System.out.println(\"Finished, start to wait\");\r\n                    System.out.println(Thread.currentThread().getName()+\" another work for 1 second\");\r\n                    Thread.sleep(1000);\r\n                }catch (Exception e){\r\n                    e.printStackTrace();\r\n                }finally {\r\n                    System.out.println(Thread.currentThread().getName() + \" finished\");\r\n                    lock.unlock();\r\n                }\r\n            }\r\n        };\r\n\r\n        Thread t2 = new Thread(){\r\n            @Override\r\n            public void run() {\r\n                try {\r\n                    Thread.sleep(100);\r\n                    lock.lock();\r\n                    System.out.println(Thread.currentThread().getName()+\" got the lock\");\r\n                    condition.signalAll();\r\n                }catch (Exception e){\r\n                    e.printStackTrace();\r\n                }finally {\r\n                    System.out.println(Thread.currentThread().getName()+\" finished\");\r\n                    lock.unlock();\r\n                }\r\n            }\r\n        };\r\n\r\n        t1.start();\r\n        t2.start();\r\n    }\r\n\r\n    public static void multipleConditionForThreadGroups(){\r\n        ReentrantLock lock = new ReentrantLock();\r\n        Condition conditionA = lock.newCondition();\r\n        Condition conditionB = lock.newCondition();\r\n\r\n        ExecutorService executorService = Executors.newFixedThreadPool(7);\r\n\r\n        //conditionA\r\n        for (int i = 0; i < 3; i++) {\r\n            executorService.submit(new Thread(){\r\n                @Override\r\n                public void run() {\r\n                    try {\r\n                        lock.lock();\r\n                        conditionA.await(2000,TimeUnit.MILLISECONDS);\r\n                        System.out.println(Thread.currentThread().getName()+\" got the lock again\");\r\n                    } catch (InterruptedException e) {\r\n                        e.printStackTrace();\r\n                    }finally {\r\n                        lock.unlock();\r\n                    }\r\n                }\r\n            });\r\n        }\r\n\r\n        //conditionB\r\n        for (int i = 0; i < 3; i++) {\r\n            executorService.submit(new Thread(){\r\n                @Override\r\n                public void run() {\r\n                    lock.lock();\r\n                    try {\r\n                        conditionB.await(2000, TimeUnit.MILLISECONDS);\r\n                        System.out.println(Thread.currentThread().getName()+\" got the lock again\");\r\n                    } catch (InterruptedException e) {\r\n                        e.printStackTrace();\r\n                    }finally {\r\n                        lock.unlock();\r\n                    }\r\n                }\r\n            });\r\n        }\r\n\r\n        executorService.submit(new Thread(){\r\n            @Override\r\n            public void run() {\r\n                try {\r\n                    Thread.sleep(1000);\r\n                    lock.lock();\r\n                    conditionA.signalAll();\r\n                    System.out.println(Thread.currentThread().getName()+\" signalAll conditionA threads\");\r\n                } catch (InterruptedException e) {\r\n                    e.printStackTrace();\r\n                }finally {\r\n                    lock.unlock();\r\n                }\r\n            }\r\n        });\r\n\r\n        executorService.shutdown();\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n        singleConditionForThreads();\r\n        multipleConditionForThreadGroups();\r\n    }\r\n}\r\n```\r\n\r\n第二个示例的输出（注意时间间隔）\r\n```java\r\n//output\r\npool-1-thread-7 signalAll conditionA threads\r\npool-1-thread-1 got the lock again\r\npool-1-thread-2 got the lock again\r\npool-1-thread-3 got the lock again\r\npool-1-thread-4 got the lock again\r\npool-1-thread-5 got the lock again\r\npool-1-thread-6 got the lock again\r\n```\r\n### Semaphore\r\nSemaphore提供了信号量机制，作为mutex（互斥量）与ReentrantLock类似，不同的是，ReentrantLock中的Condition要求线程必须持有锁，并且一个锁只能被一个线程持有，而Semaphore允许多线程访问同一资源。当Semaphore不允许访问资源时，线程会被阻塞直到可以获取permit\r\n\r\n### API\r\n方法 | 解释\r\n---|---\r\nSemaphore(int permits, boolean fair) | 构造方法，两个参数分别表示permit数量，是否公平锁，默认非公平锁\r\nacquire()|获取permit，否则阻塞直到可以获取\r\nrelease()|释放permit，注意这里可以超过构造方法中允许的permit数量，也就是可以不用acquire直接release\r\navailablePermits()|查看目前可用的permit\r\ndrainPermits()|把permit置0，返回所有permit的数量\r\n\r\n#### 与其他锁机制的对比\r\nSemaphore不关心获取锁和释放锁的对象，并且允许多线程同时访问同一资源，acquire和release只是发放和收回permit（许可），是一种相对高级的同步机制\r\n\r\n#### Semaphore Example\r\n因为是高级API，所以没啥特别的，示例中一个容量为5的信号量跑20个线程，可以防止死锁，互斥执行\r\n```java\r\npublic class SemaphoreAPI {\r\n    public static void main(String[] args) {\r\n        Semaphore semaphore = new Semaphore(5);\r\n        ExecutorService executorService = Executors.newFixedThreadPool(20);\r\n        for (int i = 0; i < 20; i++) {\r\n            executorService.submit(()->{\r\n                try {\r\n                    semaphore.acquire();\r\n                    System.out.println(Thread.currentThread().getName()+\" is doing some work\");\r\n                    Thread.sleep(1000);\r\n                } catch (InterruptedException e) {\r\n                    e.printStackTrace();\r\n                }finally {\r\n                    semaphore.release();\r\n                }\r\n            });\r\n        }\r\n        executorService.shutdown();\r\n    }\r\n}\r\n```\r\n\r\n### refs\r\nhttps://juejin.im/post/5ce91cedf265da1bca51b78a\r\nhttps://stackoverflow.com/questions/17683575/binary-semaphore-vs-a-reentrantlock\r\nhttps://www.geeksforgeeks.org/reentrant-lock-java/","frontmatter":{"abstract":"Java 多线程工具类 简介，包括 notify wait, CountDownLatch, ReentranceLock 等方法的功能和模拟","draft":null,"title":"Java Multi Thread Utils","tags":["中文","Java","multi thread","java util","jdk"],"cover":"https://unsplash.it/1152/300/?random?SuperLong","date":"2019/07/07"}}}]}},"pageContext":{"tag":"Java"}},"staticQueryHashes":[]}