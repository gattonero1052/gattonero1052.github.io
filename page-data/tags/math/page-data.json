{"componentChunkName":"component---src-templates-tag-jsx","path":"/tags/math/","result":{"data":{"allMarkdownRemark":{"totalCount":2,"edges":[{"node":{"fields":{"slug":"/algorithm/big-number-multiply","date":"2019-10-22T04:00:00.000Z"},"excerpt":"问题 适用于1000位以内数的乘法 思路 注意两点： 数字是通过字符串传过来的，字符串的低位反而是数字的高位，所以我们要从数字的低位开始计算的话，必须反转字符串（当然结果也要反转） 原理就是小学乘法，竖式计算，但不需要每次都计算进位，可以统一计算 解决 Tips…","timeToRead":2,"rawMarkdownBody":"### 问题\r\n适用于1000位以内数的乘法\r\n### 思路\r\n注意两点：\r\n- 数字是通过字符串传过来的，字符串的低位反而是数字的高位，所以我们要从数字的低位开始计算的话，必须反转字符串（当然结果也要反转）\r\n- 原理就是小学乘法，竖式计算，但不需要每次都计算进位，可以统一计算\r\n### 解决\r\n```java\r\n    public String multi(String a, String b){\r\n        ////反转字符串\r\n        char[] ar = reverse(a).toCharArray(), br = reverse(b).toCharArray();\r\n\r\n        int res[] = new int[1000];\r\n        int max = ar.length + br.length-1;//m位数乘n位数，结果至少是m+n-1位\r\n\r\n        for (int i = 0; i <max; i++) {\r\n            for (int j = 0;  i < ar.length && j < br.length; j++) {\r\n                res[i + j] += (ar[i] - 48)*(br[j] - 48);\r\n            }\r\n\r\n            if (res[i] >= 10) {\r\n                res[i+1] += res[i]/10;\r\n                res[i] %= 10;\r\n                max= Math.max(max, i+2);//结果最多是m+n位，+2是因为i是从0开始的下标，m是从1开始的位数\r\n            }\r\n        }\r\n\r\n        \r\n        StringBuilder ans = new StringBuilder();\r\n        for (int i = 0;i<max; i++) {\r\n            ans.append((char)(res[i]+48));\r\n        }\r\n\r\n        //反转结果\r\n        return ans.reverse().toString();\r\n    }\r\n\r\n    public String reverse(String s){\r\n        return new StringBuilder(s).reverse().toString();\r\n    }\r\n```\r\n### Tips\r\n- 如果追求算法简单易懂，这样是可行的，但是追求速度的话，可以使用[karatsuba](https://en.wikipedia.org/wiki/Karatsuba_algorithm)乘法，\r\n时间复杂度在n^log3级别，原理是分治，时间复杂度可以用[Master Theorem](https://en.wikipedia.org/wiki/Master_theorem_(analysis_of_algorithms)证明\r\n- karatsuba算法并不是最快的，但是是时间复杂度小于平方复杂度中的算法里相对简单的一种\r\n\r\n### Ref\r\nhttps://oi-wiki.org/math/bignum/","frontmatter":{"abstract":"大数乘法","draft":null,"title":"Big Number Multiply","tags":["中文","algorithm","math","string"],"cover":"","date":"2019/10/22"}}},{"node":{"fields":{"slug":"/algorithm/find-integer-x-y-for-ax-by-c","date":"2019-10-22T04:00:00.000Z"},"excerpt":"问题 求线性同余方程ax+by=c的整数解 思路 首先介绍下欧几里得算法的原理，众所周知，欧几里得算法是辗转相除法，这里给出证明： 假设a>b，证明 gcd(a,b) = gcd(a mod b,b)\n设a=bk+c，c=a mod b\n如果D=gcd(b,c)>gcd(a,b…","timeToRead":3,"rawMarkdownBody":"### 问题\r\n- 求线性同余方程ax+by=c的整数解\r\n\r\n### 思路\r\n首先介绍下欧几里得算法的原理，众所周知，欧几里得算法是辗转相除法，这里给出证明：\r\n\r\n假设a>b，证明 gcd(a,b) = gcd(a mod b,b)\r\n设a=bk+c，c=a mod b\r\n如果D=gcd(b,c)>gcd(a,b)，则等式 a=bk+c 右边除以D是整数，但左边除以D不是整数\r\n如果gcd(b,c)<gcd(a,b)=D，则等式 c=a-bk 右边除以D是整数，但左边除以D不是整数\r\n可见均矛盾，故gcd(b,c)=gcd(a,b)\r\n\r\n拓展欧几里得算法也是基于这个递推式，根据[裴蜀定理](https://zh.wikipedia.org/wiki/%E8%B2%9D%E7%A5%96%E7%AD%89%E5%BC%8F)，线性同余方程ax+by=c有整数解的充要条件是c|gcd(a,b)，那么我们设a>=b，有\r\n- ax1+bx2=1\r\n- 根据 gcd(a,b)=gcd(b,a mod b)=1，我们有\r\n- bx2 + (a mod b)y2=1\r\n- 若t = a/b，有\r\n- bx2 + (a mod b + bt -bt)y2 = 1\r\n化简得 ay2 + b(x2-ty2) = 1\r\n因为a mod b<b，故问题的规模可以逐步化简直至b=1，此时取一个解：xn=0, yn=1（这里也可以看出，方程有无穷多解），逐步递归即可得到答案\r\n\r\n### 解决\r\n```java\r\n    public int[] extended(int a, int b, int c){//ax+by=c\r\n        if (a<b){a^=b;b^=a;a^=b;}\r\n        return extended(a/c,b/c);\r\n    }\r\n\r\n    public int[] extended(int a, int b){\r\n        if(b==1) return new int[]{0,1};//写成b==0 return 1,0一个道理，但为什么要多一步呢？\r\n        int[] next = extended(b,a%b);\r\n        return new int[]{next[1],next[0]-a/b*next[1]};\r\n    }\r\n```\r\n\r\n\r\n\r\n### Tips\r\n- 注意裴蜀定理中c|gcd(a,b)是充要条件，也就是说如果不符合则无解，这里为了方便不考虑这种情况，另外也不考虑a=b=c=0这种特殊情况\r\n- gcd(a,b) * lcm(a,b) = a*b的证明：https://oi-wiki.org/math/gcd/#_5\r\n- ax+by=1和ax≡1(mod b)完全等价，故可以用拓展欧几里得算法来求逆元，当然求逆元也有其他方式，比如线性时间复杂度中求a以内所有数的逆元，这里不展开了\r\n- 如果不想让x或者y出现负数，可以使 x = (x+b)%b 或者 y=(y+a)%a","frontmatter":{"abstract":"求线性同余方程ax+by=c的整数解","draft":null,"title":"Find integer x,y for ax + by = c","tags":["中文","algorithm","math"],"cover":"","date":"2019/10/22"}}}]}},"pageContext":{"isCreatedByStatefulCreatePages":false,"tag":"math"}}}