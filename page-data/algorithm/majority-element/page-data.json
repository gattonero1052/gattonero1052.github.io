{"componentChunkName":"component---src-templates-post-jsx","path":"/algorithm/majority-element","result":{"data":{"markdownRemark":{"html":"<h3 id=\"问题：\"><a href=\"#%E9%97%AE%E9%A2%98%EF%BC%9A\" aria-label=\"问题： permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>问题：</h3>\n<p>给定一个n元素数组，求出现次数最大的元素（即Majority Element），并且数组保证该元素出现的次数一定大于⌊ n/2 ⌋</p>\n<h3 id=\"思路：\"><a href=\"#%E6%80%9D%E8%B7%AF%EF%BC%9A\" aria-label=\"思路： permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>思路：</h3>\n<p>空间复杂度大于O(1)或者时间复杂度大于O(n)的就不给了，介绍一个空间O(1)时间O(n)的算法</p>\n<p>对于数组an，注意到Majority Element的数量一定大于⌊ n/2 ⌋，那么任意选取一个位置ai，如果[a0...ai]内不存在这样的元素，(ai...an]内一定存在这样的元素，显然这个元素也一定是Majority Element</p>\n<p>证明：反证法，假设数字n的频数是P(n)，如果前后都不存在这样的元素，那么Pmax(a1-ai)&#x3C;=⌊ (i+1)/2 ⌋，Pmax(ai-an)&#x3C;=⌊ (n-i)/2 ⌋，即使两个数字都是n，我们也有 Pn=Pmax(a1-ai)+Pmax(ai-an)&#x3C;=⌊ n/2 ⌋，与Majority Element的频数大于⌊ n/2 ⌋矛盾，两个数字都不同的情况显然也是矛盾的</p>\n<p>接下来就是dp的思路，首先[a0]内的Majority Element就是a0\n对于位置i，通过判断ai是否是当前Majority Element来修改其频数P，那么这样会有三种情况：</p>\n<ol>\n<li>ai=Majority Element</li>\n<li>ai≠Majority Element，且P仍然>⌊ i/2 ⌋</li>\n<li>ai≠Majority Element，且使得P&#x3C;=⌊ i/2 ⌋</li>\n</ol>\n<p>对于1和2，Majority Element不变，对于3，[a0,ai]内Majority Element就不存在了，只有到i+1时，Majority Element才会等于a(i+1)，不过根据题意，这个元素一定存在，也就是说，第三种情况其实就相当于Majority Element=a(i+1)</p>\n<p>综上所述，各种情况下都能获得该位置所对应的Majority Element，该dp算法是正确的</p>\n<h3 id=\"解决：\"><a href=\"#%E8%A7%A3%E5%86%B3%EF%BC%9A\" aria-label=\"解决： permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>解决：</h3>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Solution</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> <span class=\"token function\">majorityElement</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> num<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n        <span class=\"token keyword\">int</span> major<span class=\"token operator\">=</span>num<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> count <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i<span class=\"token operator\">=</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">&lt;</span>num<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span>i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>count<span class=\"token operator\">==</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n                count<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n                major<span class=\"token operator\">=</span>num<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span><span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>major<span class=\"token operator\">==</span>num<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n                count<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span><span class=\"token keyword\">else</span> count<span class=\"token operator\">--</span><span class=\"token punctuation\">;</span>\n            \n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">return</span> major<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h3 id=\"tips\"><a href=\"#tips\" aria-label=\"tips permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Tips</h3>\n<ul>\n<li>这个算法是 Boyer–Moore 投票算法，能独立想出来很厉害了</li>\n<li>\n<p>这个元素出现的次数大于一半这个条件要注意，面试的时候没有这个条件不要装逼说这个算法</p>\n<blockquote>\n<p><a href=\"https://leetcode.com/problems/majority-element/\">https://leetcode.com/problems/majority-element/</a>\n<a href=\"https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_majority_vote_algorithm\">https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_majority_vote_algorithm</a></p>\n</blockquote>\n</li>\n</ul>","timeToRead":3,"excerpt":"问题： 给定一个n元素数组，求出现次数最大的元素（即Majority Element），并且数组保证该元素出现的次数一定大于⌊ n/2 ⌋ 思路： 空间复杂度大于O(1)或者时间复杂度大于O(n)的就不给了，介绍一个空间O(1)时间O(n)的算法 对于数组an…","frontmatter":{"title":"Majority Element","cover":"","date":"2019/3/8","category":"","tags":["中文","algorithm","array","linear time"]},"fields":{"slug":"/algorithm/majority-element","date":"2019-03-08T05:00:00.000Z"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/algorithm/majority-element","nexttitle":"","nextslug":"","prevtitle":"Check Completeness Of A Binary Tree","prevslug":"/algorithm/check-completeness-of-a-binary-tree"}}}